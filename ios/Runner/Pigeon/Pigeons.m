// Autogenerated from Pigeon (v3.2.9), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "Pigeons.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ?: [NSNull null]),
        @"message": (error.message ?: [NSNull null]),
        @"details": (error.details ?: [NSNull null]),
        };
  }
  return @{
      @"result": (result ?: [NSNull null]),
      @"error": errorDict,
      };
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface BooleanWrapper ()
+ (BooleanWrapper *)fromMap:(NSDictionary *)dict;
+ (nullable BooleanWrapper *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NumberWrapper ()
+ (NumberWrapper *)fromMap:(NSDictionary *)dict;
+ (nullable NumberWrapper *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface StringWrapper ()
+ (StringWrapper *)fromMap:(NSDictionary *)dict;
+ (nullable StringWrapper *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface ListWrapper ()
+ (ListWrapper *)fromMap:(NSDictionary *)dict;
+ (nullable ListWrapper *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface PebbleFirmwarePigeon ()
+ (PebbleFirmwarePigeon *)fromMap:(NSDictionary *)dict;
+ (nullable PebbleFirmwarePigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface PebbleDevicePigeon ()
+ (PebbleDevicePigeon *)fromMap:(NSDictionary *)dict;
+ (nullable PebbleDevicePigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface PebbleScanDevicePigeon ()
+ (PebbleScanDevicePigeon *)fromMap:(NSDictionary *)dict;
+ (nullable PebbleScanDevicePigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface WatchConnectionStatePigeon ()
+ (WatchConnectionStatePigeon *)fromMap:(NSDictionary *)dict;
+ (nullable WatchConnectionStatePigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface TimelinePinPigeon ()
+ (TimelinePinPigeon *)fromMap:(NSDictionary *)dict;
+ (nullable TimelinePinPigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface ActionTrigger ()
+ (ActionTrigger *)fromMap:(NSDictionary *)dict;
+ (nullable ActionTrigger *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface ActionResponsePigeon ()
+ (ActionResponsePigeon *)fromMap:(NSDictionary *)dict;
+ (nullable ActionResponsePigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NotifActionExecuteReq ()
+ (NotifActionExecuteReq *)fromMap:(NSDictionary *)dict;
+ (nullable NotifActionExecuteReq *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NotificationPigeon ()
+ (NotificationPigeon *)fromMap:(NSDictionary *)dict;
+ (nullable NotificationPigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface AppEntriesPigeon ()
+ (AppEntriesPigeon *)fromMap:(NSDictionary *)dict;
+ (nullable AppEntriesPigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface PbwAppInfo ()
+ (PbwAppInfo *)fromMap:(NSDictionary *)dict;
+ (nullable PbwAppInfo *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface WatchappInfo ()
+ (WatchappInfo *)fromMap:(NSDictionary *)dict;
+ (nullable WatchappInfo *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface WatchResource ()
+ (WatchResource *)fromMap:(NSDictionary *)dict;
+ (nullable WatchResource *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface InstallData ()
+ (InstallData *)fromMap:(NSDictionary *)dict;
+ (nullable InstallData *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface AppInstallStatus ()
+ (AppInstallStatus *)fromMap:(NSDictionary *)dict;
+ (nullable AppInstallStatus *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface ScreenshotResult ()
+ (ScreenshotResult *)fromMap:(NSDictionary *)dict;
+ (nullable ScreenshotResult *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface AppLogEntry ()
+ (AppLogEntry *)fromMap:(NSDictionary *)dict;
+ (nullable AppLogEntry *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface OAuthResult ()
+ (OAuthResult *)fromMap:(NSDictionary *)dict;
+ (nullable OAuthResult *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface NotifChannelPigeon ()
+ (NotifChannelPigeon *)fromMap:(NSDictionary *)dict;
+ (nullable NotifChannelPigeon *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation BooleanWrapper
+ (instancetype)makeWithValue:(nullable NSNumber *)value {
  BooleanWrapper* pigeonResult = [[BooleanWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (BooleanWrapper *)fromMap:(NSDictionary *)dict {
  BooleanWrapper *pigeonResult = [[BooleanWrapper alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  return pigeonResult;
}
+ (nullable BooleanWrapper *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [BooleanWrapper fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
  };
}
@end

@implementation NumberWrapper
+ (instancetype)makeWithValue:(nullable NSNumber *)value {
  NumberWrapper* pigeonResult = [[NumberWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (NumberWrapper *)fromMap:(NSDictionary *)dict {
  NumberWrapper *pigeonResult = [[NumberWrapper alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  return pigeonResult;
}
+ (nullable NumberWrapper *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NumberWrapper fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
  };
}
@end

@implementation StringWrapper
+ (instancetype)makeWithValue:(nullable NSString *)value {
  StringWrapper* pigeonResult = [[StringWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (StringWrapper *)fromMap:(NSDictionary *)dict {
  StringWrapper *pigeonResult = [[StringWrapper alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  return pigeonResult;
}
+ (nullable StringWrapper *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [StringWrapper fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
  };
}
@end

@implementation ListWrapper
+ (instancetype)makeWithValue:(nullable NSArray *)value {
  ListWrapper* pigeonResult = [[ListWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (ListWrapper *)fromMap:(NSDictionary *)dict {
  ListWrapper *pigeonResult = [[ListWrapper alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  return pigeonResult;
}
+ (nullable ListWrapper *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [ListWrapper fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
  };
}
@end

@implementation PebbleFirmwarePigeon
+ (instancetype)makeWithTimestamp:(nullable NSNumber *)timestamp
    version:(nullable NSString *)version
    gitHash:(nullable NSString *)gitHash
    isRecovery:(nullable NSNumber *)isRecovery
    hardwarePlatform:(nullable NSNumber *)hardwarePlatform
    metadataVersion:(nullable NSNumber *)metadataVersion {
  PebbleFirmwarePigeon* pigeonResult = [[PebbleFirmwarePigeon alloc] init];
  pigeonResult.timestamp = timestamp;
  pigeonResult.version = version;
  pigeonResult.gitHash = gitHash;
  pigeonResult.isRecovery = isRecovery;
  pigeonResult.hardwarePlatform = hardwarePlatform;
  pigeonResult.metadataVersion = metadataVersion;
  return pigeonResult;
}
+ (PebbleFirmwarePigeon *)fromMap:(NSDictionary *)dict {
  PebbleFirmwarePigeon *pigeonResult = [[PebbleFirmwarePigeon alloc] init];
  pigeonResult.timestamp = GetNullableObject(dict, @"timestamp");
  pigeonResult.version = GetNullableObject(dict, @"version");
  pigeonResult.gitHash = GetNullableObject(dict, @"gitHash");
  pigeonResult.isRecovery = GetNullableObject(dict, @"isRecovery");
  pigeonResult.hardwarePlatform = GetNullableObject(dict, @"hardwarePlatform");
  pigeonResult.metadataVersion = GetNullableObject(dict, @"metadataVersion");
  return pigeonResult;
}
+ (nullable PebbleFirmwarePigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [PebbleFirmwarePigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"timestamp" : (self.timestamp ?: [NSNull null]),
    @"version" : (self.version ?: [NSNull null]),
    @"gitHash" : (self.gitHash ?: [NSNull null]),
    @"isRecovery" : (self.isRecovery ?: [NSNull null]),
    @"hardwarePlatform" : (self.hardwarePlatform ?: [NSNull null]),
    @"metadataVersion" : (self.metadataVersion ?: [NSNull null]),
  };
}
@end

@implementation PebbleDevicePigeon
+ (instancetype)makeWithName:(nullable NSString *)name
    address:(nullable NSString *)address
    runningFirmware:(nullable PebbleFirmwarePigeon *)runningFirmware
    recoveryFirmware:(nullable PebbleFirmwarePigeon *)recoveryFirmware
    model:(nullable NSNumber *)model
    bootloaderTimestamp:(nullable NSNumber *)bootloaderTimestamp
    board:(nullable NSString *)board
    serial:(nullable NSString *)serial
    language:(nullable NSString *)language
    languageVersion:(nullable NSNumber *)languageVersion
    isUnfaithful:(nullable NSNumber *)isUnfaithful {
  PebbleDevicePigeon* pigeonResult = [[PebbleDevicePigeon alloc] init];
  pigeonResult.name = name;
  pigeonResult.address = address;
  pigeonResult.runningFirmware = runningFirmware;
  pigeonResult.recoveryFirmware = recoveryFirmware;
  pigeonResult.model = model;
  pigeonResult.bootloaderTimestamp = bootloaderTimestamp;
  pigeonResult.board = board;
  pigeonResult.serial = serial;
  pigeonResult.language = language;
  pigeonResult.languageVersion = languageVersion;
  pigeonResult.isUnfaithful = isUnfaithful;
  return pigeonResult;
}
+ (PebbleDevicePigeon *)fromMap:(NSDictionary *)dict {
  PebbleDevicePigeon *pigeonResult = [[PebbleDevicePigeon alloc] init];
  pigeonResult.name = GetNullableObject(dict, @"name");
  pigeonResult.address = GetNullableObject(dict, @"address");
  pigeonResult.runningFirmware = [PebbleFirmwarePigeon nullableFromMap:GetNullableObject(dict, @"runningFirmware")];
  pigeonResult.recoveryFirmware = [PebbleFirmwarePigeon nullableFromMap:GetNullableObject(dict, @"recoveryFirmware")];
  pigeonResult.model = GetNullableObject(dict, @"model");
  pigeonResult.bootloaderTimestamp = GetNullableObject(dict, @"bootloaderTimestamp");
  pigeonResult.board = GetNullableObject(dict, @"board");
  pigeonResult.serial = GetNullableObject(dict, @"serial");
  pigeonResult.language = GetNullableObject(dict, @"language");
  pigeonResult.languageVersion = GetNullableObject(dict, @"languageVersion");
  pigeonResult.isUnfaithful = GetNullableObject(dict, @"isUnfaithful");
  return pigeonResult;
}
+ (nullable PebbleDevicePigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [PebbleDevicePigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"name" : (self.name ?: [NSNull null]),
    @"address" : (self.address ?: [NSNull null]),
    @"runningFirmware" : (self.runningFirmware ? [self.runningFirmware toMap] : [NSNull null]),
    @"recoveryFirmware" : (self.recoveryFirmware ? [self.recoveryFirmware toMap] : [NSNull null]),
    @"model" : (self.model ?: [NSNull null]),
    @"bootloaderTimestamp" : (self.bootloaderTimestamp ?: [NSNull null]),
    @"board" : (self.board ?: [NSNull null]),
    @"serial" : (self.serial ?: [NSNull null]),
    @"language" : (self.language ?: [NSNull null]),
    @"languageVersion" : (self.languageVersion ?: [NSNull null]),
    @"isUnfaithful" : (self.isUnfaithful ?: [NSNull null]),
  };
}
@end

@implementation PebbleScanDevicePigeon
+ (instancetype)makeWithName:(nullable NSString *)name
    address:(nullable NSString *)address
    version:(nullable NSString *)version
    serialNumber:(nullable NSString *)serialNumber
    color:(nullable NSNumber *)color
    runningPRF:(nullable NSNumber *)runningPRF
    firstUse:(nullable NSNumber *)firstUse {
  PebbleScanDevicePigeon* pigeonResult = [[PebbleScanDevicePigeon alloc] init];
  pigeonResult.name = name;
  pigeonResult.address = address;
  pigeonResult.version = version;
  pigeonResult.serialNumber = serialNumber;
  pigeonResult.color = color;
  pigeonResult.runningPRF = runningPRF;
  pigeonResult.firstUse = firstUse;
  return pigeonResult;
}
+ (PebbleScanDevicePigeon *)fromMap:(NSDictionary *)dict {
  PebbleScanDevicePigeon *pigeonResult = [[PebbleScanDevicePigeon alloc] init];
  pigeonResult.name = GetNullableObject(dict, @"name");
  pigeonResult.address = GetNullableObject(dict, @"address");
  pigeonResult.version = GetNullableObject(dict, @"version");
  pigeonResult.serialNumber = GetNullableObject(dict, @"serialNumber");
  pigeonResult.color = GetNullableObject(dict, @"color");
  pigeonResult.runningPRF = GetNullableObject(dict, @"runningPRF");
  pigeonResult.firstUse = GetNullableObject(dict, @"firstUse");
  return pigeonResult;
}
+ (nullable PebbleScanDevicePigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [PebbleScanDevicePigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"name" : (self.name ?: [NSNull null]),
    @"address" : (self.address ?: [NSNull null]),
    @"version" : (self.version ?: [NSNull null]),
    @"serialNumber" : (self.serialNumber ?: [NSNull null]),
    @"color" : (self.color ?: [NSNull null]),
    @"runningPRF" : (self.runningPRF ?: [NSNull null]),
    @"firstUse" : (self.firstUse ?: [NSNull null]),
  };
}
@end

@implementation WatchConnectionStatePigeon
+ (instancetype)makeWithIsConnected:(nullable NSNumber *)isConnected
    isConnecting:(nullable NSNumber *)isConnecting
    currentWatchAddress:(nullable NSString *)currentWatchAddress
    currentConnectedWatch:(nullable PebbleDevicePigeon *)currentConnectedWatch {
  WatchConnectionStatePigeon* pigeonResult = [[WatchConnectionStatePigeon alloc] init];
  pigeonResult.isConnected = isConnected;
  pigeonResult.isConnecting = isConnecting;
  pigeonResult.currentWatchAddress = currentWatchAddress;
  pigeonResult.currentConnectedWatch = currentConnectedWatch;
  return pigeonResult;
}
+ (WatchConnectionStatePigeon *)fromMap:(NSDictionary *)dict {
  WatchConnectionStatePigeon *pigeonResult = [[WatchConnectionStatePigeon alloc] init];
  pigeonResult.isConnected = GetNullableObject(dict, @"isConnected");
  pigeonResult.isConnecting = GetNullableObject(dict, @"isConnecting");
  pigeonResult.currentWatchAddress = GetNullableObject(dict, @"currentWatchAddress");
  pigeonResult.currentConnectedWatch = [PebbleDevicePigeon nullableFromMap:GetNullableObject(dict, @"currentConnectedWatch")];
  return pigeonResult;
}
+ (nullable WatchConnectionStatePigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [WatchConnectionStatePigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"isConnected" : (self.isConnected ?: [NSNull null]),
    @"isConnecting" : (self.isConnecting ?: [NSNull null]),
    @"currentWatchAddress" : (self.currentWatchAddress ?: [NSNull null]),
    @"currentConnectedWatch" : (self.currentConnectedWatch ? [self.currentConnectedWatch toMap] : [NSNull null]),
  };
}
@end

@implementation TimelinePinPigeon
+ (instancetype)makeWithItemId:(nullable NSString *)itemId
    parentId:(nullable NSString *)parentId
    timestamp:(nullable NSNumber *)timestamp
    type:(nullable NSNumber *)type
    duration:(nullable NSNumber *)duration
    isVisible:(nullable NSNumber *)isVisible
    isFloating:(nullable NSNumber *)isFloating
    isAllDay:(nullable NSNumber *)isAllDay
    persistQuickView:(nullable NSNumber *)persistQuickView
    layout:(nullable NSNumber *)layout
    attributesJson:(nullable NSString *)attributesJson
    actionsJson:(nullable NSString *)actionsJson {
  TimelinePinPigeon* pigeonResult = [[TimelinePinPigeon alloc] init];
  pigeonResult.itemId = itemId;
  pigeonResult.parentId = parentId;
  pigeonResult.timestamp = timestamp;
  pigeonResult.type = type;
  pigeonResult.duration = duration;
  pigeonResult.isVisible = isVisible;
  pigeonResult.isFloating = isFloating;
  pigeonResult.isAllDay = isAllDay;
  pigeonResult.persistQuickView = persistQuickView;
  pigeonResult.layout = layout;
  pigeonResult.attributesJson = attributesJson;
  pigeonResult.actionsJson = actionsJson;
  return pigeonResult;
}
+ (TimelinePinPigeon *)fromMap:(NSDictionary *)dict {
  TimelinePinPigeon *pigeonResult = [[TimelinePinPigeon alloc] init];
  pigeonResult.itemId = GetNullableObject(dict, @"itemId");
  pigeonResult.parentId = GetNullableObject(dict, @"parentId");
  pigeonResult.timestamp = GetNullableObject(dict, @"timestamp");
  pigeonResult.type = GetNullableObject(dict, @"type");
  pigeonResult.duration = GetNullableObject(dict, @"duration");
  pigeonResult.isVisible = GetNullableObject(dict, @"isVisible");
  pigeonResult.isFloating = GetNullableObject(dict, @"isFloating");
  pigeonResult.isAllDay = GetNullableObject(dict, @"isAllDay");
  pigeonResult.persistQuickView = GetNullableObject(dict, @"persistQuickView");
  pigeonResult.layout = GetNullableObject(dict, @"layout");
  pigeonResult.attributesJson = GetNullableObject(dict, @"attributesJson");
  pigeonResult.actionsJson = GetNullableObject(dict, @"actionsJson");
  return pigeonResult;
}
+ (nullable TimelinePinPigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [TimelinePinPigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"itemId" : (self.itemId ?: [NSNull null]),
    @"parentId" : (self.parentId ?: [NSNull null]),
    @"timestamp" : (self.timestamp ?: [NSNull null]),
    @"type" : (self.type ?: [NSNull null]),
    @"duration" : (self.duration ?: [NSNull null]),
    @"isVisible" : (self.isVisible ?: [NSNull null]),
    @"isFloating" : (self.isFloating ?: [NSNull null]),
    @"isAllDay" : (self.isAllDay ?: [NSNull null]),
    @"persistQuickView" : (self.persistQuickView ?: [NSNull null]),
    @"layout" : (self.layout ?: [NSNull null]),
    @"attributesJson" : (self.attributesJson ?: [NSNull null]),
    @"actionsJson" : (self.actionsJson ?: [NSNull null]),
  };
}
@end

@implementation ActionTrigger
+ (instancetype)makeWithItemId:(nullable NSString *)itemId
    actionId:(nullable NSNumber *)actionId
    attributesJson:(nullable NSString *)attributesJson {
  ActionTrigger* pigeonResult = [[ActionTrigger alloc] init];
  pigeonResult.itemId = itemId;
  pigeonResult.actionId = actionId;
  pigeonResult.attributesJson = attributesJson;
  return pigeonResult;
}
+ (ActionTrigger *)fromMap:(NSDictionary *)dict {
  ActionTrigger *pigeonResult = [[ActionTrigger alloc] init];
  pigeonResult.itemId = GetNullableObject(dict, @"itemId");
  pigeonResult.actionId = GetNullableObject(dict, @"actionId");
  pigeonResult.attributesJson = GetNullableObject(dict, @"attributesJson");
  return pigeonResult;
}
+ (nullable ActionTrigger *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [ActionTrigger fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"itemId" : (self.itemId ?: [NSNull null]),
    @"actionId" : (self.actionId ?: [NSNull null]),
    @"attributesJson" : (self.attributesJson ?: [NSNull null]),
  };
}
@end

@implementation ActionResponsePigeon
+ (instancetype)makeWithSuccess:(nullable NSNumber *)success
    attributesJson:(nullable NSString *)attributesJson {
  ActionResponsePigeon* pigeonResult = [[ActionResponsePigeon alloc] init];
  pigeonResult.success = success;
  pigeonResult.attributesJson = attributesJson;
  return pigeonResult;
}
+ (ActionResponsePigeon *)fromMap:(NSDictionary *)dict {
  ActionResponsePigeon *pigeonResult = [[ActionResponsePigeon alloc] init];
  pigeonResult.success = GetNullableObject(dict, @"success");
  pigeonResult.attributesJson = GetNullableObject(dict, @"attributesJson");
  return pigeonResult;
}
+ (nullable ActionResponsePigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [ActionResponsePigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"success" : (self.success ?: [NSNull null]),
    @"attributesJson" : (self.attributesJson ?: [NSNull null]),
  };
}
@end

@implementation NotifActionExecuteReq
+ (instancetype)makeWithItemId:(nullable NSString *)itemId
    actionId:(nullable NSNumber *)actionId
    responseText:(nullable NSString *)responseText {
  NotifActionExecuteReq* pigeonResult = [[NotifActionExecuteReq alloc] init];
  pigeonResult.itemId = itemId;
  pigeonResult.actionId = actionId;
  pigeonResult.responseText = responseText;
  return pigeonResult;
}
+ (NotifActionExecuteReq *)fromMap:(NSDictionary *)dict {
  NotifActionExecuteReq *pigeonResult = [[NotifActionExecuteReq alloc] init];
  pigeonResult.itemId = GetNullableObject(dict, @"itemId");
  pigeonResult.actionId = GetNullableObject(dict, @"actionId");
  pigeonResult.responseText = GetNullableObject(dict, @"responseText");
  return pigeonResult;
}
+ (nullable NotifActionExecuteReq *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NotifActionExecuteReq fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"itemId" : (self.itemId ?: [NSNull null]),
    @"actionId" : (self.actionId ?: [NSNull null]),
    @"responseText" : (self.responseText ?: [NSNull null]),
  };
}
@end

@implementation NotificationPigeon
+ (instancetype)makeWithPackageId:(nullable NSString *)packageId
    notifId:(nullable NSNumber *)notifId
    appName:(nullable NSString *)appName
    tagId:(nullable NSString *)tagId
    title:(nullable NSString *)title
    text:(nullable NSString *)text
    category:(nullable NSString *)category
    color:(nullable NSNumber *)color
    messagesJson:(nullable NSString *)messagesJson
    actionsJson:(nullable NSString *)actionsJson {
  NotificationPigeon* pigeonResult = [[NotificationPigeon alloc] init];
  pigeonResult.packageId = packageId;
  pigeonResult.notifId = notifId;
  pigeonResult.appName = appName;
  pigeonResult.tagId = tagId;
  pigeonResult.title = title;
  pigeonResult.text = text;
  pigeonResult.category = category;
  pigeonResult.color = color;
  pigeonResult.messagesJson = messagesJson;
  pigeonResult.actionsJson = actionsJson;
  return pigeonResult;
}
+ (NotificationPigeon *)fromMap:(NSDictionary *)dict {
  NotificationPigeon *pigeonResult = [[NotificationPigeon alloc] init];
  pigeonResult.packageId = GetNullableObject(dict, @"packageId");
  pigeonResult.notifId = GetNullableObject(dict, @"notifId");
  pigeonResult.appName = GetNullableObject(dict, @"appName");
  pigeonResult.tagId = GetNullableObject(dict, @"tagId");
  pigeonResult.title = GetNullableObject(dict, @"title");
  pigeonResult.text = GetNullableObject(dict, @"text");
  pigeonResult.category = GetNullableObject(dict, @"category");
  pigeonResult.color = GetNullableObject(dict, @"color");
  pigeonResult.messagesJson = GetNullableObject(dict, @"messagesJson");
  pigeonResult.actionsJson = GetNullableObject(dict, @"actionsJson");
  return pigeonResult;
}
+ (nullable NotificationPigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NotificationPigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"packageId" : (self.packageId ?: [NSNull null]),
    @"notifId" : (self.notifId ?: [NSNull null]),
    @"appName" : (self.appName ?: [NSNull null]),
    @"tagId" : (self.tagId ?: [NSNull null]),
    @"title" : (self.title ?: [NSNull null]),
    @"text" : (self.text ?: [NSNull null]),
    @"category" : (self.category ?: [NSNull null]),
    @"color" : (self.color ?: [NSNull null]),
    @"messagesJson" : (self.messagesJson ?: [NSNull null]),
    @"actionsJson" : (self.actionsJson ?: [NSNull null]),
  };
}
@end

@implementation AppEntriesPigeon
+ (instancetype)makeWithAppName:(nullable NSArray<NSString *> *)appName
    packageId:(nullable NSArray<NSString *> *)packageId {
  AppEntriesPigeon* pigeonResult = [[AppEntriesPigeon alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.packageId = packageId;
  return pigeonResult;
}
+ (AppEntriesPigeon *)fromMap:(NSDictionary *)dict {
  AppEntriesPigeon *pigeonResult = [[AppEntriesPigeon alloc] init];
  pigeonResult.appName = GetNullableObject(dict, @"appName");
  pigeonResult.packageId = GetNullableObject(dict, @"packageId");
  return pigeonResult;
}
+ (nullable AppEntriesPigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [AppEntriesPigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"appName" : (self.appName ?: [NSNull null]),
    @"packageId" : (self.packageId ?: [NSNull null]),
  };
}
@end

@implementation PbwAppInfo
+ (instancetype)makeWithIsValid:(nullable NSNumber *)isValid
    uuid:(nullable NSString *)uuid
    shortName:(nullable NSString *)shortName
    longName:(nullable NSString *)longName
    companyName:(nullable NSString *)companyName
    versionCode:(nullable NSNumber *)versionCode
    versionLabel:(nullable NSString *)versionLabel
    appKeys:(nullable NSDictionary<NSString *, NSNumber *> *)appKeys
    capabilities:(nullable NSArray<NSString *> *)capabilities
    resources:(nullable NSArray<WatchResource *> *)resources
    sdkVersion:(nullable NSString *)sdkVersion
    targetPlatforms:(nullable NSArray<NSString *> *)targetPlatforms
    watchapp:(nullable WatchappInfo *)watchapp {
  PbwAppInfo* pigeonResult = [[PbwAppInfo alloc] init];
  pigeonResult.isValid = isValid;
  pigeonResult.uuid = uuid;
  pigeonResult.shortName = shortName;
  pigeonResult.longName = longName;
  pigeonResult.companyName = companyName;
  pigeonResult.versionCode = versionCode;
  pigeonResult.versionLabel = versionLabel;
  pigeonResult.appKeys = appKeys;
  pigeonResult.capabilities = capabilities;
  pigeonResult.resources = resources;
  pigeonResult.sdkVersion = sdkVersion;
  pigeonResult.targetPlatforms = targetPlatforms;
  pigeonResult.watchapp = watchapp;
  return pigeonResult;
}
+ (PbwAppInfo *)fromMap:(NSDictionary *)dict {
  PbwAppInfo *pigeonResult = [[PbwAppInfo alloc] init];
  pigeonResult.isValid = GetNullableObject(dict, @"isValid");
  pigeonResult.uuid = GetNullableObject(dict, @"uuid");
  pigeonResult.shortName = GetNullableObject(dict, @"shortName");
  pigeonResult.longName = GetNullableObject(dict, @"longName");
  pigeonResult.companyName = GetNullableObject(dict, @"companyName");
  pigeonResult.versionCode = GetNullableObject(dict, @"versionCode");
  pigeonResult.versionLabel = GetNullableObject(dict, @"versionLabel");
  pigeonResult.appKeys = GetNullableObject(dict, @"appKeys");
  pigeonResult.capabilities = GetNullableObject(dict, @"capabilities");
  pigeonResult.resources = GetNullableObject(dict, @"resources");
  pigeonResult.sdkVersion = GetNullableObject(dict, @"sdkVersion");
  pigeonResult.targetPlatforms = GetNullableObject(dict, @"targetPlatforms");
  pigeonResult.watchapp = [WatchappInfo nullableFromMap:GetNullableObject(dict, @"watchapp")];
  return pigeonResult;
}
+ (nullable PbwAppInfo *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [PbwAppInfo fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"isValid" : (self.isValid ?: [NSNull null]),
    @"uuid" : (self.uuid ?: [NSNull null]),
    @"shortName" : (self.shortName ?: [NSNull null]),
    @"longName" : (self.longName ?: [NSNull null]),
    @"companyName" : (self.companyName ?: [NSNull null]),
    @"versionCode" : (self.versionCode ?: [NSNull null]),
    @"versionLabel" : (self.versionLabel ?: [NSNull null]),
    @"appKeys" : (self.appKeys ?: [NSNull null]),
    @"capabilities" : (self.capabilities ?: [NSNull null]),
    @"resources" : (self.resources ?: [NSNull null]),
    @"sdkVersion" : (self.sdkVersion ?: [NSNull null]),
    @"targetPlatforms" : (self.targetPlatforms ?: [NSNull null]),
    @"watchapp" : (self.watchapp ? [self.watchapp toMap] : [NSNull null]),
  };
}
@end

@implementation WatchappInfo
+ (instancetype)makeWithWatchface:(nullable NSNumber *)watchface
    hiddenApp:(nullable NSNumber *)hiddenApp
    onlyShownOnCommunication:(nullable NSNumber *)onlyShownOnCommunication {
  WatchappInfo* pigeonResult = [[WatchappInfo alloc] init];
  pigeonResult.watchface = watchface;
  pigeonResult.hiddenApp = hiddenApp;
  pigeonResult.onlyShownOnCommunication = onlyShownOnCommunication;
  return pigeonResult;
}
+ (WatchappInfo *)fromMap:(NSDictionary *)dict {
  WatchappInfo *pigeonResult = [[WatchappInfo alloc] init];
  pigeonResult.watchface = GetNullableObject(dict, @"watchface");
  pigeonResult.hiddenApp = GetNullableObject(dict, @"hiddenApp");
  pigeonResult.onlyShownOnCommunication = GetNullableObject(dict, @"onlyShownOnCommunication");
  return pigeonResult;
}
+ (nullable WatchappInfo *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [WatchappInfo fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"watchface" : (self.watchface ?: [NSNull null]),
    @"hiddenApp" : (self.hiddenApp ?: [NSNull null]),
    @"onlyShownOnCommunication" : (self.onlyShownOnCommunication ?: [NSNull null]),
  };
}
@end

@implementation WatchResource
+ (instancetype)makeWithFile:(nullable NSString *)file
    menuIcon:(nullable NSNumber *)menuIcon
    name:(nullable NSString *)name
    type:(nullable NSString *)type {
  WatchResource* pigeonResult = [[WatchResource alloc] init];
  pigeonResult.file = file;
  pigeonResult.menuIcon = menuIcon;
  pigeonResult.name = name;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (WatchResource *)fromMap:(NSDictionary *)dict {
  WatchResource *pigeonResult = [[WatchResource alloc] init];
  pigeonResult.file = GetNullableObject(dict, @"file");
  pigeonResult.menuIcon = GetNullableObject(dict, @"menuIcon");
  pigeonResult.name = GetNullableObject(dict, @"name");
  pigeonResult.type = GetNullableObject(dict, @"type");
  return pigeonResult;
}
+ (nullable WatchResource *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [WatchResource fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"file" : (self.file ?: [NSNull null]),
    @"menuIcon" : (self.menuIcon ?: [NSNull null]),
    @"name" : (self.name ?: [NSNull null]),
    @"type" : (self.type ?: [NSNull null]),
  };
}
@end

@implementation InstallData
+ (instancetype)makeWithUri:(NSString *)uri
    appInfo:(PbwAppInfo *)appInfo
    stayOffloaded:(NSNumber *)stayOffloaded {
  InstallData* pigeonResult = [[InstallData alloc] init];
  pigeonResult.uri = uri;
  pigeonResult.appInfo = appInfo;
  pigeonResult.stayOffloaded = stayOffloaded;
  return pigeonResult;
}
+ (InstallData *)fromMap:(NSDictionary *)dict {
  InstallData *pigeonResult = [[InstallData alloc] init];
  pigeonResult.uri = GetNullableObject(dict, @"uri");
  NSAssert(pigeonResult.uri != nil, @"");
  pigeonResult.appInfo = [PbwAppInfo nullableFromMap:GetNullableObject(dict, @"appInfo")];
  NSAssert(pigeonResult.appInfo != nil, @"");
  pigeonResult.stayOffloaded = GetNullableObject(dict, @"stayOffloaded");
  NSAssert(pigeonResult.stayOffloaded != nil, @"");
  return pigeonResult;
}
+ (nullable InstallData *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [InstallData fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"uri" : (self.uri ?: [NSNull null]),
    @"appInfo" : (self.appInfo ? [self.appInfo toMap] : [NSNull null]),
    @"stayOffloaded" : (self.stayOffloaded ?: [NSNull null]),
  };
}
@end

@implementation AppInstallStatus
+ (instancetype)makeWithProgress:(NSNumber *)progress
    isInstalling:(NSNumber *)isInstalling {
  AppInstallStatus* pigeonResult = [[AppInstallStatus alloc] init];
  pigeonResult.progress = progress;
  pigeonResult.isInstalling = isInstalling;
  return pigeonResult;
}
+ (AppInstallStatus *)fromMap:(NSDictionary *)dict {
  AppInstallStatus *pigeonResult = [[AppInstallStatus alloc] init];
  pigeonResult.progress = GetNullableObject(dict, @"progress");
  NSAssert(pigeonResult.progress != nil, @"");
  pigeonResult.isInstalling = GetNullableObject(dict, @"isInstalling");
  NSAssert(pigeonResult.isInstalling != nil, @"");
  return pigeonResult;
}
+ (nullable AppInstallStatus *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [AppInstallStatus fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"progress" : (self.progress ?: [NSNull null]),
    @"isInstalling" : (self.isInstalling ?: [NSNull null]),
  };
}
@end

@implementation ScreenshotResult
+ (instancetype)makeWithSuccess:(NSNumber *)success
    imagePath:(nullable NSString *)imagePath {
  ScreenshotResult* pigeonResult = [[ScreenshotResult alloc] init];
  pigeonResult.success = success;
  pigeonResult.imagePath = imagePath;
  return pigeonResult;
}
+ (ScreenshotResult *)fromMap:(NSDictionary *)dict {
  ScreenshotResult *pigeonResult = [[ScreenshotResult alloc] init];
  pigeonResult.success = GetNullableObject(dict, @"success");
  NSAssert(pigeonResult.success != nil, @"");
  pigeonResult.imagePath = GetNullableObject(dict, @"imagePath");
  return pigeonResult;
}
+ (nullable ScreenshotResult *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [ScreenshotResult fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"success" : (self.success ?: [NSNull null]),
    @"imagePath" : (self.imagePath ?: [NSNull null]),
  };
}
@end

@implementation AppLogEntry
+ (instancetype)makeWithUuid:(NSString *)uuid
    timestamp:(NSNumber *)timestamp
    level:(NSNumber *)level
    lineNumber:(NSNumber *)lineNumber
    filename:(NSString *)filename
    message:(NSString *)message {
  AppLogEntry* pigeonResult = [[AppLogEntry alloc] init];
  pigeonResult.uuid = uuid;
  pigeonResult.timestamp = timestamp;
  pigeonResult.level = level;
  pigeonResult.lineNumber = lineNumber;
  pigeonResult.filename = filename;
  pigeonResult.message = message;
  return pigeonResult;
}
+ (AppLogEntry *)fromMap:(NSDictionary *)dict {
  AppLogEntry *pigeonResult = [[AppLogEntry alloc] init];
  pigeonResult.uuid = GetNullableObject(dict, @"uuid");
  NSAssert(pigeonResult.uuid != nil, @"");
  pigeonResult.timestamp = GetNullableObject(dict, @"timestamp");
  NSAssert(pigeonResult.timestamp != nil, @"");
  pigeonResult.level = GetNullableObject(dict, @"level");
  NSAssert(pigeonResult.level != nil, @"");
  pigeonResult.lineNumber = GetNullableObject(dict, @"lineNumber");
  NSAssert(pigeonResult.lineNumber != nil, @"");
  pigeonResult.filename = GetNullableObject(dict, @"filename");
  NSAssert(pigeonResult.filename != nil, @"");
  pigeonResult.message = GetNullableObject(dict, @"message");
  NSAssert(pigeonResult.message != nil, @"");
  return pigeonResult;
}
+ (nullable AppLogEntry *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [AppLogEntry fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"uuid" : (self.uuid ?: [NSNull null]),
    @"timestamp" : (self.timestamp ?: [NSNull null]),
    @"level" : (self.level ?: [NSNull null]),
    @"lineNumber" : (self.lineNumber ?: [NSNull null]),
    @"filename" : (self.filename ?: [NSNull null]),
    @"message" : (self.message ?: [NSNull null]),
  };
}
@end

@implementation OAuthResult
+ (instancetype)makeWithCode:(nullable NSString *)code
    state:(nullable NSString *)state
    error:(nullable NSString *)error {
  OAuthResult* pigeonResult = [[OAuthResult alloc] init];
  pigeonResult.code = code;
  pigeonResult.state = state;
  pigeonResult.error = error;
  return pigeonResult;
}
+ (OAuthResult *)fromMap:(NSDictionary *)dict {
  OAuthResult *pigeonResult = [[OAuthResult alloc] init];
  pigeonResult.code = GetNullableObject(dict, @"code");
  pigeonResult.state = GetNullableObject(dict, @"state");
  pigeonResult.error = GetNullableObject(dict, @"error");
  return pigeonResult;
}
+ (nullable OAuthResult *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [OAuthResult fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"code" : (self.code ?: [NSNull null]),
    @"state" : (self.state ?: [NSNull null]),
    @"error" : (self.error ?: [NSNull null]),
  };
}
@end

@implementation NotifChannelPigeon
+ (instancetype)makeWithPackageId:(nullable NSString *)packageId
    channelId:(nullable NSString *)channelId
    channelName:(nullable NSString *)channelName
    channelDesc:(nullable NSString *)channelDesc
    delete:(nullable NSNumber *)delete {
  NotifChannelPigeon* pigeonResult = [[NotifChannelPigeon alloc] init];
  pigeonResult.packageId = packageId;
  pigeonResult.channelId = channelId;
  pigeonResult.channelName = channelName;
  pigeonResult.channelDesc = channelDesc;
  pigeonResult.delete = delete;
  return pigeonResult;
}
+ (NotifChannelPigeon *)fromMap:(NSDictionary *)dict {
  NotifChannelPigeon *pigeonResult = [[NotifChannelPigeon alloc] init];
  pigeonResult.packageId = GetNullableObject(dict, @"packageId");
  pigeonResult.channelId = GetNullableObject(dict, @"channelId");
  pigeonResult.channelName = GetNullableObject(dict, @"channelName");
  pigeonResult.channelDesc = GetNullableObject(dict, @"channelDesc");
  pigeonResult.delete = GetNullableObject(dict, @"delete");
  return pigeonResult;
}
+ (nullable NotifChannelPigeon *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [NotifChannelPigeon fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"packageId" : (self.packageId ?: [NSNull null]),
    @"channelId" : (self.channelId ?: [NSNull null]),
    @"channelName" : (self.channelName ?: [NSNull null]),
    @"channelDesc" : (self.channelDesc ?: [NSNull null]),
    @"delete" : (self.delete ?: [NSNull null]),
  };
}
@end

@interface ScanCallbacksCodecReader : FlutterStandardReader
@end
@implementation ScanCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [ListWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface ScanCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation ScanCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface ScanCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ScanCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ScanCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ScanCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ScanCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    ScanCallbacksCodecReaderWriter *readerWriter = [[ScanCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface ScanCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation ScanCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onScanUpdatePebbles:(ListWrapper *)arg_pebbles completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanUpdate"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:@[arg_pebbles ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onScanStartedWithCompletion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanStarted"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onScanStoppedWithCompletion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanStopped"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface ConnectionCallbacksCodecReader : FlutterStandardReader
@end
@implementation ConnectionCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [PebbleDevicePigeon fromMap:[self readValue]];
    
    case 129:     
      return [PebbleFirmwarePigeon fromMap:[self readValue]];
    
    case 130:     
      return [WatchConnectionStatePigeon fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface ConnectionCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation ConnectionCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[PebbleDevicePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[PebbleFirmwarePigeon class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchConnectionStatePigeon class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface ConnectionCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ConnectionCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ConnectionCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ConnectionCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ConnectionCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    ConnectionCallbacksCodecReaderWriter *readerWriter = [[ConnectionCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface ConnectionCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation ConnectionCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onWatchConnectionStateChangedNewState:(WatchConnectionStatePigeon *)arg_newState completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged"
      binaryMessenger:self.binaryMessenger
      codec:ConnectionCallbacksGetCodec()];
  [channel sendMessage:@[arg_newState ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface RawIncomingPacketsCallbacksCodecReader : FlutterStandardReader
@end
@implementation RawIncomingPacketsCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [ListWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface RawIncomingPacketsCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation RawIncomingPacketsCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface RawIncomingPacketsCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation RawIncomingPacketsCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[RawIncomingPacketsCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[RawIncomingPacketsCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *RawIncomingPacketsCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    RawIncomingPacketsCallbacksCodecReaderWriter *readerWriter = [[RawIncomingPacketsCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface RawIncomingPacketsCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation RawIncomingPacketsCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onPacketReceivedListOfBytes:(ListWrapper *)arg_listOfBytes completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived"
      binaryMessenger:self.binaryMessenger
      codec:RawIncomingPacketsCallbacksGetCodec()];
  [channel sendMessage:@[arg_listOfBytes ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface PairCallbacksCodecReader : FlutterStandardReader
@end
@implementation PairCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface PairCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation PairCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface PairCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PairCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PairCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PairCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PairCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    PairCallbacksCodecReaderWriter *readerWriter = [[PairCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface PairCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation PairCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onWatchPairCompleteAddress:(StringWrapper *)arg_address completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.PairCallbacks.onWatchPairComplete"
      binaryMessenger:self.binaryMessenger
      codec:PairCallbacksGetCodec()];
  [channel sendMessage:@[arg_address ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface CalendarCallbacksCodecReader : FlutterStandardReader
@end
@implementation CalendarCallbacksCodecReader
@end

@interface CalendarCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation CalendarCallbacksCodecWriter
@end

@interface CalendarCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CalendarCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CalendarCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CalendarCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *CalendarCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    CalendarCallbacksCodecReaderWriter *readerWriter = [[CalendarCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface CalendarCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation CalendarCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)doFullCalendarSyncWithCompletion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.CalendarCallbacks.doFullCalendarSync"
      binaryMessenger:self.binaryMessenger
      codec:CalendarCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface TimelineCallbacksCodecReader : FlutterStandardReader
@end
@implementation TimelineCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [ActionResponsePigeon fromMap:[self readValue]];
    
    case 129:     
      return [ActionTrigger fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface TimelineCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation TimelineCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[ActionResponsePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[ActionTrigger class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface TimelineCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TimelineCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TimelineCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TimelineCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TimelineCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    TimelineCallbacksCodecReaderWriter *readerWriter = [[TimelineCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface TimelineCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation TimelineCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)syncTimelineToWatchWithCompletion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.TimelineCallbacks.syncTimelineToWatch"
      binaryMessenger:self.binaryMessenger
      codec:TimelineCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
- (void)handleTimelineActionActionTrigger:(ActionTrigger *)arg_actionTrigger completion:(void(^)(ActionResponsePigeon *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.TimelineCallbacks.handleTimelineAction"
      binaryMessenger:self.binaryMessenger
      codec:TimelineCallbacksGetCodec()];
  [channel sendMessage:@[arg_actionTrigger ?: [NSNull null]] reply:^(id reply) {
    ActionResponsePigeon *output = reply;
    completion(output, nil);
  }];
}
@end
@interface IntentCallbacksCodecReader : FlutterStandardReader
@end
@implementation IntentCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface IntentCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation IntentCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface IntentCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation IntentCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[IntentCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[IntentCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *IntentCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    IntentCallbacksCodecReaderWriter *readerWriter = [[IntentCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface IntentCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation IntentCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)openUriUri:(StringWrapper *)arg_uri completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.IntentCallbacks.openUri"
      binaryMessenger:self.binaryMessenger
      codec:IntentCallbacksGetCodec()];
  [channel sendMessage:@[arg_uri ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface BackgroundAppInstallCallbacksCodecReader : FlutterStandardReader
@end
@implementation BackgroundAppInstallCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [InstallData fromMap:[self readValue]];
    
    case 129:     
      return [PbwAppInfo fromMap:[self readValue]];
    
    case 130:     
      return [StringWrapper fromMap:[self readValue]];
    
    case 131:     
      return [WatchResource fromMap:[self readValue]];
    
    case 132:     
      return [WatchappInfo fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface BackgroundAppInstallCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation BackgroundAppInstallCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[InstallData class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[PbwAppInfo class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchResource class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchappInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface BackgroundAppInstallCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation BackgroundAppInstallCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[BackgroundAppInstallCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[BackgroundAppInstallCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *BackgroundAppInstallCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    BackgroundAppInstallCallbacksCodecReaderWriter *readerWriter = [[BackgroundAppInstallCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface BackgroundAppInstallCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation BackgroundAppInstallCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)beginAppInstallInstallData:(InstallData *)arg_installData completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.BackgroundAppInstallCallbacks.beginAppInstall"
      binaryMessenger:self.binaryMessenger
      codec:BackgroundAppInstallCallbacksGetCodec()];
  [channel sendMessage:@[arg_installData ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)deleteAppUuid:(StringWrapper *)arg_uuid completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.BackgroundAppInstallCallbacks.deleteApp"
      binaryMessenger:self.binaryMessenger
      codec:BackgroundAppInstallCallbacksGetCodec()];
  [channel sendMessage:@[arg_uuid ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface AppInstallStatusCallbacksCodecReader : FlutterStandardReader
@end
@implementation AppInstallStatusCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [AppInstallStatus fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface AppInstallStatusCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation AppInstallStatusCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[AppInstallStatus class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface AppInstallStatusCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppInstallStatusCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppInstallStatusCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppInstallStatusCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppInstallStatusCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AppInstallStatusCallbacksCodecReaderWriter *readerWriter = [[AppInstallStatusCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface AppInstallStatusCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation AppInstallStatusCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onStatusUpdatedStatus:(AppInstallStatus *)arg_status completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated"
      binaryMessenger:self.binaryMessenger
      codec:AppInstallStatusCallbacksGetCodec()];
  [channel sendMessage:@[arg_status ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface NotificationListeningCodecReader : FlutterStandardReader
@end
@implementation NotificationListeningCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    case 129:     
      return [NotifChannelPigeon fromMap:[self readValue]];
    
    case 130:     
      return [NotificationPigeon fromMap:[self readValue]];
    
    case 131:     
      return [StringWrapper fromMap:[self readValue]];
    
    case 132:     
      return [TimelinePinPigeon fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface NotificationListeningCodecWriter : FlutterStandardWriter
@end
@implementation NotificationListeningCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NotifChannelPigeon class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NotificationPigeon class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[TimelinePinPigeon class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface NotificationListeningCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NotificationListeningCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NotificationListeningCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NotificationListeningCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NotificationListeningGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NotificationListeningCodecReaderWriter *readerWriter = [[NotificationListeningCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface NotificationListening ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation NotificationListening

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)handleNotificationNotification:(NotificationPigeon *)arg_notification completion:(void(^)(TimelinePinPigeon *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NotificationListening.handleNotification"
      binaryMessenger:self.binaryMessenger
      codec:NotificationListeningGetCodec()];
  [channel sendMessage:@[arg_notification ?: [NSNull null]] reply:^(id reply) {
    TimelinePinPigeon *output = reply;
    completion(output, nil);
  }];
}
- (void)dismissNotificationItemId:(StringWrapper *)arg_itemId completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NotificationListening.dismissNotification"
      binaryMessenger:self.binaryMessenger
      codec:NotificationListeningGetCodec()];
  [channel sendMessage:@[arg_itemId ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)shouldNotifyChannel:(NotifChannelPigeon *)arg_channel completion:(void(^)(BooleanWrapper *_Nullable, NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NotificationListening.shouldNotify"
      binaryMessenger:self.binaryMessenger
      codec:NotificationListeningGetCodec()];
  [channel sendMessage:@[arg_channel ?: [NSNull null]] reply:^(id reply) {
    BooleanWrapper *output = reply;
    completion(output, nil);
  }];
}
- (void)updateChannelChannel:(NotifChannelPigeon *)arg_channel completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.NotificationListening.updateChannel"
      binaryMessenger:self.binaryMessenger
      codec:NotificationListeningGetCodec()];
  [channel sendMessage:@[arg_channel ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface AppLogCallbacksCodecReader : FlutterStandardReader
@end
@implementation AppLogCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [AppLogEntry fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface AppLogCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation AppLogCallbacksCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[AppLogEntry class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface AppLogCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppLogCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppLogCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppLogCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppLogCallbacksGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AppLogCallbacksCodecReaderWriter *readerWriter = [[AppLogCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


@interface AppLogCallbacks ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation AppLogCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onLogReceivedEntry:(AppLogEntry *)arg_entry completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.AppLogCallbacks.onLogReceived"
      binaryMessenger:self.binaryMessenger
      codec:AppLogCallbacksGetCodec()];
  [channel sendMessage:@[arg_entry ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end
@interface NotificationUtilsCodecReader : FlutterStandardReader
@end
@implementation NotificationUtilsCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    case 129:     
      return [NotifActionExecuteReq fromMap:[self readValue]];
    
    case 130:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface NotificationUtilsCodecWriter : FlutterStandardWriter
@end
@implementation NotificationUtilsCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NotifActionExecuteReq class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface NotificationUtilsCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NotificationUtilsCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NotificationUtilsCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NotificationUtilsCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NotificationUtilsGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NotificationUtilsCodecReaderWriter *readerWriter = [[NotificationUtilsCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void NotificationUtilsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<NotificationUtils> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.dismissNotification"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dismissNotificationItemId:completion:)], @"NotificationUtils api (%@) doesn't respond to @selector(dismissNotificationItemId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        [api dismissNotificationItemId:arg_itemId completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.dismissNotificationWatch"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dismissNotificationWatchItemId:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(dismissNotificationWatchItemId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dismissNotificationWatchItemId:arg_itemId error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.openNotification"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openNotificationItemId:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(openNotificationItemId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api openNotificationItemId:arg_itemId error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.executeAction"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(executeActionAction:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(executeActionAction:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NotifActionExecuteReq *arg_action = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api executeActionAction:arg_action error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ScanControlCodecReader : FlutterStandardReader
@end
@implementation ScanControlCodecReader
@end

@interface ScanControlCodecWriter : FlutterStandardWriter
@end
@implementation ScanControlCodecWriter
@end

@interface ScanControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ScanControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ScanControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ScanControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ScanControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    ScanControlCodecReaderWriter *readerWriter = [[ScanControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void ScanControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ScanControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScanControl.startBleScan"
        binaryMessenger:binaryMessenger
        codec:ScanControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startBleScanWithError:)], @"ScanControl api (%@) doesn't respond to @selector(startBleScanWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startBleScanWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScanControl.startClassicScan"
        binaryMessenger:binaryMessenger
        codec:ScanControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startClassicScanWithError:)], @"ScanControl api (%@) doesn't respond to @selector(startClassicScanWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startClassicScanWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ConnectionControlCodecReader : FlutterStandardReader
@end
@implementation ConnectionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    case 129:     
      return [ListWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface ConnectionControlCodecWriter : FlutterStandardWriter
@end
@implementation ConnectionControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface ConnectionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ConnectionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ConnectionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ConnectionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ConnectionControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    ConnectionControlCodecReaderWriter *readerWriter = [[ConnectionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void ConnectionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ConnectionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.isConnected"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isConnectedWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(isConnectedWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api isConnectedWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.disconnect"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(disconnectWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(disconnectWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api disconnectWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.sendRawPacket"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendRawPacketListOfBytes:error:)], @"ConnectionControl api (%@) doesn't respond to @selector(sendRawPacketListOfBytes:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        ListWrapper *arg_listOfBytes = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api sendRawPacketListOfBytes:arg_listOfBytes error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.observeConnectionChanges"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(observeConnectionChangesWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(observeConnectionChangesWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api observeConnectionChangesWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.cancelObservingConnectionChanges"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelObservingConnectionChangesWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(cancelObservingConnectionChangesWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelObservingConnectionChangesWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface RawIncomingPacketsControlCodecReader : FlutterStandardReader
@end
@implementation RawIncomingPacketsControlCodecReader
@end

@interface RawIncomingPacketsControlCodecWriter : FlutterStandardWriter
@end
@implementation RawIncomingPacketsControlCodecWriter
@end

@interface RawIncomingPacketsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation RawIncomingPacketsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[RawIncomingPacketsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[RawIncomingPacketsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *RawIncomingPacketsControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    RawIncomingPacketsControlCodecReaderWriter *readerWriter = [[RawIncomingPacketsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void RawIncomingPacketsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<RawIncomingPacketsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.RawIncomingPacketsControl.observeIncomingPackets"
        binaryMessenger:binaryMessenger
        codec:RawIncomingPacketsControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(observeIncomingPacketsWithError:)], @"RawIncomingPacketsControl api (%@) doesn't respond to @selector(observeIncomingPacketsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api observeIncomingPacketsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.RawIncomingPacketsControl.cancelObservingIncomingPackets"
        binaryMessenger:binaryMessenger
        codec:RawIncomingPacketsControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelObservingIncomingPacketsWithError:)], @"RawIncomingPacketsControl api (%@) doesn't respond to @selector(cancelObservingIncomingPacketsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelObservingIncomingPacketsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface UiConnectionControlCodecReader : FlutterStandardReader
@end
@implementation UiConnectionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface UiConnectionControlCodecWriter : FlutterStandardWriter
@end
@implementation UiConnectionControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface UiConnectionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation UiConnectionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[UiConnectionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[UiConnectionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *UiConnectionControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    UiConnectionControlCodecReaderWriter *readerWriter = [[UiConnectionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void UiConnectionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<UiConnectionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.UiConnectionControl.connectToWatch"
        binaryMessenger:binaryMessenger
        codec:UiConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(connectToWatchMacAddress:error:)], @"UiConnectionControl api (%@) doesn't respond to @selector(connectToWatchMacAddress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_macAddress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api connectToWatchMacAddress:arg_macAddress error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.UiConnectionControl.unpairWatch"
        binaryMessenger:binaryMessenger
        codec:UiConnectionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unpairWatchMacAddress:error:)], @"UiConnectionControl api (%@) doesn't respond to @selector(unpairWatchMacAddress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_macAddress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api unpairWatchMacAddress:arg_macAddress error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface NotificationsControlCodecReader : FlutterStandardReader
@end
@implementation NotificationsControlCodecReader
@end

@interface NotificationsControlCodecWriter : FlutterStandardWriter
@end
@implementation NotificationsControlCodecWriter
@end

@interface NotificationsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NotificationsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NotificationsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NotificationsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NotificationsControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    NotificationsControlCodecReaderWriter *readerWriter = [[NotificationsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void NotificationsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<NotificationsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationsControl.sendTestNotification"
        binaryMessenger:binaryMessenger
        codec:NotificationsControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendTestNotificationWithError:)], @"NotificationsControl api (%@) doesn't respond to @selector(sendTestNotificationWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api sendTestNotificationWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface IntentControlCodecReader : FlutterStandardReader
@end
@implementation IntentControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [OAuthResult fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface IntentControlCodecWriter : FlutterStandardWriter
@end
@implementation IntentControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[OAuthResult class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface IntentControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation IntentControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[IntentControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[IntentControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *IntentControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    IntentControlCodecReaderWriter *readerWriter = [[IntentControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void IntentControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<IntentControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.notifyFlutterReadyForIntents"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(notifyFlutterReadyForIntentsWithError:)], @"IntentControl api (%@) doesn't respond to @selector(notifyFlutterReadyForIntentsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api notifyFlutterReadyForIntentsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.notifyFlutterNotReadyForIntents"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(notifyFlutterNotReadyForIntentsWithError:)], @"IntentControl api (%@) doesn't respond to @selector(notifyFlutterNotReadyForIntentsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api notifyFlutterNotReadyForIntentsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.waitForOAuth"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForOAuthWithCompletion:)], @"IntentControl api (%@) doesn't respond to @selector(waitForOAuthWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api waitForOAuthWithCompletion:^(OAuthResult *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface DebugControlCodecReader : FlutterStandardReader
@end
@implementation DebugControlCodecReader
@end

@interface DebugControlCodecWriter : FlutterStandardWriter
@end
@implementation DebugControlCodecWriter
@end

@interface DebugControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation DebugControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[DebugControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[DebugControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *DebugControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    DebugControlCodecReaderWriter *readerWriter = [[DebugControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void DebugControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<DebugControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.DebugControl.collectLogs"
        binaryMessenger:binaryMessenger
        codec:DebugControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(collectLogsWithError:)], @"DebugControl api (%@) doesn't respond to @selector(collectLogsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api collectLogsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface TimelineControlCodecReader : FlutterStandardReader
@end
@implementation TimelineControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NumberWrapper fromMap:[self readValue]];
    
    case 129:     
      return [StringWrapper fromMap:[self readValue]];
    
    case 130:     
      return [TimelinePinPigeon fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface TimelineControlCodecWriter : FlutterStandardWriter
@end
@implementation TimelineControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[TimelinePinPigeon class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface TimelineControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TimelineControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TimelineControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TimelineControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TimelineControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    TimelineControlCodecReaderWriter *readerWriter = [[TimelineControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void TimelineControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<TimelineControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.addPin"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addPinPin:completion:)], @"TimelineControl api (%@) doesn't respond to @selector(addPinPin:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        TimelinePinPigeon *arg_pin = GetNullableObjectAtIndex(args, 0);
        [api addPinPin:arg_pin completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.removePin"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removePinPinUuid:completion:)], @"TimelineControl api (%@) doesn't respond to @selector(removePinPinUuid:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_pinUuid = GetNullableObjectAtIndex(args, 0);
        [api removePinPinUuid:arg_pinUuid completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.removeAllPins"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeAllPinsWithCompletion:)], @"TimelineControl api (%@) doesn't respond to @selector(removeAllPinsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api removeAllPinsWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface BackgroundSetupControlCodecReader : FlutterStandardReader
@end
@implementation BackgroundSetupControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NumberWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface BackgroundSetupControlCodecWriter : FlutterStandardWriter
@end
@implementation BackgroundSetupControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface BackgroundSetupControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation BackgroundSetupControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[BackgroundSetupControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[BackgroundSetupControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *BackgroundSetupControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    BackgroundSetupControlCodecReaderWriter *readerWriter = [[BackgroundSetupControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void BackgroundSetupControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<BackgroundSetupControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.BackgroundSetupControl.setupBackground"
        binaryMessenger:binaryMessenger
        codec:BackgroundSetupControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setupBackgroundCallbackHandle:error:)], @"BackgroundSetupControl api (%@) doesn't respond to @selector(setupBackgroundCallbackHandle:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NumberWrapper *arg_callbackHandle = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setupBackgroundCallbackHandle:arg_callbackHandle error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface BackgroundControlCodecReader : FlutterStandardReader
@end
@implementation BackgroundControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NumberWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface BackgroundControlCodecWriter : FlutterStandardWriter
@end
@implementation BackgroundControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface BackgroundControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation BackgroundControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[BackgroundControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[BackgroundControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *BackgroundControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    BackgroundControlCodecReaderWriter *readerWriter = [[BackgroundControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void BackgroundControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<BackgroundControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.BackgroundControl.notifyFlutterBackgroundStarted"
        binaryMessenger:binaryMessenger
        codec:BackgroundControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(notifyFlutterBackgroundStartedWithCompletion:)], @"BackgroundControl api (%@) doesn't respond to @selector(notifyFlutterBackgroundStartedWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api notifyFlutterBackgroundStartedWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PermissionCheckCodecReader : FlutterStandardReader
@end
@implementation PermissionCheckCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface PermissionCheckCodecWriter : FlutterStandardWriter
@end
@implementation PermissionCheckCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface PermissionCheckCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PermissionCheckCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PermissionCheckCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PermissionCheckCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PermissionCheckGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    PermissionCheckCodecReaderWriter *readerWriter = [[PermissionCheckCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void PermissionCheckSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PermissionCheck> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasLocationPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasLocationPermissionWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasLocationPermissionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasLocationPermissionWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasCalendarPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasCalendarPermissionWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasCalendarPermissionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasCalendarPermissionWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasNotificationAccess"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasNotificationAccessWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasNotificationAccessWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasNotificationAccessWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasBatteryExclusionEnabled"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasBatteryExclusionEnabledWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasBatteryExclusionEnabledWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasBatteryExclusionEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PermissionControlCodecReader : FlutterStandardReader
@end
@implementation PermissionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [NumberWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface PermissionControlCodecWriter : FlutterStandardWriter
@end
@implementation PermissionControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface PermissionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PermissionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PermissionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PermissionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PermissionControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    PermissionControlCodecReaderWriter *readerWriter = [[PermissionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void PermissionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PermissionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestLocationPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestLocationPermissionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestLocationPermissionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestLocationPermissionWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestCalendarPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestCalendarPermissionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestCalendarPermissionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestCalendarPermissionWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestNotificationAccess"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestNotificationAccessWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestNotificationAccessWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestNotificationAccessWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestBatteryExclusion"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestBatteryExclusionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestBatteryExclusionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestBatteryExclusionWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestBluetoothPermissions"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestBluetoothPermissionsWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestBluetoothPermissionsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestBluetoothPermissionsWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.openPermissionSettings"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openPermissionSettingsWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(openPermissionSettingsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api openPermissionSettingsWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface CalendarControlCodecReader : FlutterStandardReader
@end
@implementation CalendarControlCodecReader
@end

@interface CalendarControlCodecWriter : FlutterStandardWriter
@end
@implementation CalendarControlCodecWriter
@end

@interface CalendarControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CalendarControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CalendarControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CalendarControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *CalendarControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    CalendarControlCodecReaderWriter *readerWriter = [[CalendarControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void CalendarControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CalendarControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.requestCalendarSync"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestCalendarSyncWithError:)], @"CalendarControl api (%@) doesn't respond to @selector(requestCalendarSyncWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api requestCalendarSyncWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PigeonLoggerCodecReader : FlutterStandardReader
@end
@implementation PigeonLoggerCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface PigeonLoggerCodecWriter : FlutterStandardWriter
@end
@implementation PigeonLoggerCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface PigeonLoggerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PigeonLoggerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PigeonLoggerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PigeonLoggerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PigeonLoggerGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    PigeonLoggerCodecReaderWriter *readerWriter = [[PigeonLoggerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void PigeonLoggerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PigeonLogger> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.v"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(vMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(vMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api vMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.d"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(dMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.i"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(iMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(iMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api iMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.w"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(wMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(wMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api wMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.e"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(eMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(eMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api eMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface TimelineSyncControlCodecReader : FlutterStandardReader
@end
@implementation TimelineSyncControlCodecReader
@end

@interface TimelineSyncControlCodecWriter : FlutterStandardWriter
@end
@implementation TimelineSyncControlCodecWriter
@end

@interface TimelineSyncControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TimelineSyncControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TimelineSyncControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TimelineSyncControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TimelineSyncControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    TimelineSyncControlCodecReaderWriter *readerWriter = [[TimelineSyncControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void TimelineSyncControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<TimelineSyncControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineSyncControl.syncTimelineToWatchLater"
        binaryMessenger:binaryMessenger
        codec:TimelineSyncControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(syncTimelineToWatchLaterWithError:)], @"TimelineSyncControl api (%@) doesn't respond to @selector(syncTimelineToWatchLaterWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api syncTimelineToWatchLaterWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface WorkaroundsControlCodecReader : FlutterStandardReader
@end
@implementation WorkaroundsControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [ListWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface WorkaroundsControlCodecWriter : FlutterStandardWriter
@end
@implementation WorkaroundsControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface WorkaroundsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation WorkaroundsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[WorkaroundsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[WorkaroundsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *WorkaroundsControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    WorkaroundsControlCodecReaderWriter *readerWriter = [[WorkaroundsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void WorkaroundsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<WorkaroundsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.WorkaroundsControl.getNeededWorkarounds"
        binaryMessenger:binaryMessenger
        codec:WorkaroundsControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getNeededWorkaroundsWithError:)], @"WorkaroundsControl api (%@) doesn't respond to @selector(getNeededWorkaroundsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        ListWrapper *output = [api getNeededWorkaroundsWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AppInstallControlCodecReader : FlutterStandardReader
@end
@implementation AppInstallControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    case 129:     
      return [InstallData fromMap:[self readValue]];
    
    case 130:     
      return [ListWrapper fromMap:[self readValue]];
    
    case 131:     
      return [NumberWrapper fromMap:[self readValue]];
    
    case 132:     
      return [PbwAppInfo fromMap:[self readValue]];
    
    case 133:     
      return [StringWrapper fromMap:[self readValue]];
    
    case 134:     
      return [WatchResource fromMap:[self readValue]];
    
    case 135:     
      return [WatchappInfo fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface AppInstallControlCodecWriter : FlutterStandardWriter
@end
@implementation AppInstallControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[InstallData class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[PbwAppInfo class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchResource class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchappInfo class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface AppInstallControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppInstallControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppInstallControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppInstallControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppInstallControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AppInstallControlCodecReaderWriter *readerWriter = [[AppInstallControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void AppInstallControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppInstallControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.getAppInfo"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAppInfoLocalPbwUri:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(getAppInfoLocalPbwUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_localPbwUri = GetNullableObjectAtIndex(args, 0);
        [api getAppInfoLocalPbwUri:arg_localPbwUri completion:^(PbwAppInfo *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.beginAppInstall"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(beginAppInstallInstallData:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(beginAppInstallInstallData:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        InstallData *arg_installData = GetNullableObjectAtIndex(args, 0);
        [api beginAppInstallInstallData:arg_installData completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.beginAppDeletion"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(beginAppDeletionUuid:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(beginAppDeletionUuid:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_uuid = GetNullableObjectAtIndex(args, 0);
        [api beginAppDeletionUuid:arg_uuid completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.insertAppIntoBlobDb"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(insertAppIntoBlobDbUuidString:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(insertAppIntoBlobDbUuidString:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_uuidString = GetNullableObjectAtIndex(args, 0);
        [api insertAppIntoBlobDbUuidString:arg_uuidString completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.removeAppFromBlobDb"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeAppFromBlobDbAppUuidString:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(removeAppFromBlobDbAppUuidString:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_appUuidString = GetNullableObjectAtIndex(args, 0);
        [api removeAppFromBlobDbAppUuidString:arg_appUuidString completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.removeAllApps"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeAllAppsWithCompletion:)], @"AppInstallControl api (%@) doesn't respond to @selector(removeAllAppsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api removeAllAppsWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.subscribeToAppStatus"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(subscribeToAppStatusWithError:)], @"AppInstallControl api (%@) doesn't respond to @selector(subscribeToAppStatusWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api subscribeToAppStatusWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.unsubscribeFromAppStatus"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unsubscribeFromAppStatusWithError:)], @"AppInstallControl api (%@) doesn't respond to @selector(unsubscribeFromAppStatusWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api unsubscribeFromAppStatusWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.sendAppOrderToWatch"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendAppOrderToWatchUuidStringList:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(sendAppOrderToWatchUuidStringList:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        ListWrapper *arg_uuidStringList = GetNullableObjectAtIndex(args, 0);
        [api sendAppOrderToWatchUuidStringList:arg_uuidStringList completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AppLifecycleControlCodecReader : FlutterStandardReader
@end
@implementation AppLifecycleControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [BooleanWrapper fromMap:[self readValue]];
    
    case 129:     
      return [StringWrapper fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface AppLifecycleControlCodecWriter : FlutterStandardWriter
@end
@implementation AppLifecycleControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface AppLifecycleControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppLifecycleControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppLifecycleControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppLifecycleControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppLifecycleControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AppLifecycleControlCodecReaderWriter *readerWriter = [[AppLifecycleControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void AppLifecycleControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppLifecycleControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLifecycleControl.openAppOnTheWatch"
        binaryMessenger:binaryMessenger
        codec:AppLifecycleControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openAppOnTheWatchUuidString:completion:)], @"AppLifecycleControl api (%@) doesn't respond to @selector(openAppOnTheWatchUuidString:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_uuidString = GetNullableObjectAtIndex(args, 0);
        [api openAppOnTheWatchUuidString:arg_uuidString completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PackageDetailsCodecReader : FlutterStandardReader
@end
@implementation PackageDetailsCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [AppEntriesPigeon fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface PackageDetailsCodecWriter : FlutterStandardWriter
@end
@implementation PackageDetailsCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[AppEntriesPigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface PackageDetailsCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PackageDetailsCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PackageDetailsCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PackageDetailsCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PackageDetailsGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    PackageDetailsCodecReaderWriter *readerWriter = [[PackageDetailsCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void PackageDetailsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PackageDetails> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PackageDetails.getPackageList"
        binaryMessenger:binaryMessenger
        codec:PackageDetailsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPackageListWithError:)], @"PackageDetails api (%@) doesn't respond to @selector(getPackageListWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        AppEntriesPigeon *output = [api getPackageListWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ScreenshotsControlCodecReader : FlutterStandardReader
@end
@implementation ScreenshotsControlCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [ScreenshotResult fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface ScreenshotsControlCodecWriter : FlutterStandardWriter
@end
@implementation ScreenshotsControlCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[ScreenshotResult class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface ScreenshotsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ScreenshotsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ScreenshotsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ScreenshotsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ScreenshotsControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    ScreenshotsControlCodecReaderWriter *readerWriter = [[ScreenshotsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void ScreenshotsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ScreenshotsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScreenshotsControl.takeWatchScreenshot"
        binaryMessenger:binaryMessenger
        codec:ScreenshotsControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(takeWatchScreenshotWithCompletion:)], @"ScreenshotsControl api (%@) doesn't respond to @selector(takeWatchScreenshotWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api takeWatchScreenshotWithCompletion:^(ScreenshotResult *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AppLogControlCodecReader : FlutterStandardReader
@end
@implementation AppLogControlCodecReader
@end

@interface AppLogControlCodecWriter : FlutterStandardWriter
@end
@implementation AppLogControlCodecWriter
@end

@interface AppLogControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppLogControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppLogControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppLogControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppLogControlGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    AppLogControlCodecReaderWriter *readerWriter = [[AppLogControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void AppLogControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppLogControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLogControl.startSendingLogs"
        binaryMessenger:binaryMessenger
        codec:AppLogControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startSendingLogsWithError:)], @"AppLogControl api (%@) doesn't respond to @selector(startSendingLogsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startSendingLogsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLogControl.stopSendingLogs"
        binaryMessenger:binaryMessenger
        codec:AppLogControlGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopSendingLogsWithError:)], @"AppLogControl api (%@) doesn't respond to @selector(stopSendingLogsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api stopSendingLogsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface KeepUnusedHackCodecReader : FlutterStandardReader
@end
@implementation KeepUnusedHackCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [PebbleScanDevicePigeon fromMap:[self readValue]];
    
    case 129:     
      return [WatchResource fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface KeepUnusedHackCodecWriter : FlutterStandardWriter
@end
@implementation KeepUnusedHackCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[PebbleScanDevicePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[WatchResource class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface KeepUnusedHackCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation KeepUnusedHackCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[KeepUnusedHackCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[KeepUnusedHackCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *KeepUnusedHackGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    KeepUnusedHackCodecReaderWriter *readerWriter = [[KeepUnusedHackCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void KeepUnusedHackSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<KeepUnusedHack> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KeepUnusedHack.keepPebbleScanDevicePigeon"
        binaryMessenger:binaryMessenger
        codec:KeepUnusedHackGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(keepPebbleScanDevicePigeonCls:error:)], @"KeepUnusedHack api (%@) doesn't respond to @selector(keepPebbleScanDevicePigeonCls:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PebbleScanDevicePigeon *arg_cls = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api keepPebbleScanDevicePigeonCls:arg_cls error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KeepUnusedHack.keepWatchResource"
        binaryMessenger:binaryMessenger
        codec:KeepUnusedHackGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(keepWatchResourceCls:error:)], @"KeepUnusedHack api (%@) doesn't respond to @selector(keepWatchResourceCls:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        WatchResource *arg_cls = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api keepWatchResourceCls:arg_cls error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
