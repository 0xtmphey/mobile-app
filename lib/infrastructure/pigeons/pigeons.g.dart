// Autogenerated from Pigeon (v1.0.19), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class BooleanWrapper {
  BooleanWrapper({
    this.value,
  });

  bool? value;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  static BooleanWrapper decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return BooleanWrapper(
      value: pigeonMap['value'] as bool?,
    );
  }
}

class NumberWrapper {
  NumberWrapper({
    this.value,
  });

  int? value;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  static NumberWrapper decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return NumberWrapper(
      value: pigeonMap['value'] as int?,
    );
  }
}

class StringWrapper {
  StringWrapper({
    this.value,
  });

  String? value;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  static StringWrapper decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return StringWrapper(
      value: pigeonMap['value'] as String?,
    );
  }
}

class ListWrapper {
  ListWrapper({
    this.value,
  });

  List<Object?>? value;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  static ListWrapper decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ListWrapper(
      value: pigeonMap['value'] as List<Object?>?,
    );
  }
}

class PebbleFirmwarePigeon {
  PebbleFirmwarePigeon({
    this.timestamp,
    this.version,
    this.gitHash,
    this.isRecovery,
    this.hardwarePlatform,
    this.metadataVersion,
  });

  int? timestamp;
  String? version;
  String? gitHash;
  bool? isRecovery;
  int? hardwarePlatform;
  int? metadataVersion;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['timestamp'] = timestamp;
    pigeonMap['version'] = version;
    pigeonMap['gitHash'] = gitHash;
    pigeonMap['isRecovery'] = isRecovery;
    pigeonMap['hardwarePlatform'] = hardwarePlatform;
    pigeonMap['metadataVersion'] = metadataVersion;
    return pigeonMap;
  }

  static PebbleFirmwarePigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PebbleFirmwarePigeon(
      timestamp: pigeonMap['timestamp'] as int?,
      version: pigeonMap['version'] as String?,
      gitHash: pigeonMap['gitHash'] as String?,
      isRecovery: pigeonMap['isRecovery'] as bool?,
      hardwarePlatform: pigeonMap['hardwarePlatform'] as int?,
      metadataVersion: pigeonMap['metadataVersion'] as int?,
    );
  }
}

class PebbleDevicePigeon {
  PebbleDevicePigeon({
    this.name,
    this.address,
    this.runningFirmware,
    this.recoveryFirmware,
    this.model,
    this.bootloaderTimestamp,
    this.board,
    this.serial,
    this.language,
    this.languageVersion,
    this.isUnfaithful,
  });

  String? name;
  String? address;
  PebbleFirmwarePigeon? runningFirmware;
  PebbleFirmwarePigeon? recoveryFirmware;
  int? model;
  int? bootloaderTimestamp;
  String? board;
  String? serial;
  String? language;
  int? languageVersion;
  bool? isUnfaithful;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['name'] = name;
    pigeonMap['address'] = address;
    pigeonMap['runningFirmware'] = runningFirmware == null ? null : runningFirmware!.encode();
    pigeonMap['recoveryFirmware'] = recoveryFirmware == null ? null : recoveryFirmware!.encode();
    pigeonMap['model'] = model;
    pigeonMap['bootloaderTimestamp'] = bootloaderTimestamp;
    pigeonMap['board'] = board;
    pigeonMap['serial'] = serial;
    pigeonMap['language'] = language;
    pigeonMap['languageVersion'] = languageVersion;
    pigeonMap['isUnfaithful'] = isUnfaithful;
    return pigeonMap;
  }

  static PebbleDevicePigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PebbleDevicePigeon(
      name: pigeonMap['name'] as String?,
      address: pigeonMap['address'] as String?,
      runningFirmware: pigeonMap['runningFirmware'] != null
          ? PebbleFirmwarePigeon.decode(pigeonMap['runningFirmware']!)
          : null,
      recoveryFirmware: pigeonMap['recoveryFirmware'] != null
          ? PebbleFirmwarePigeon.decode(pigeonMap['recoveryFirmware']!)
          : null,
      model: pigeonMap['model'] as int?,
      bootloaderTimestamp: pigeonMap['bootloaderTimestamp'] as int?,
      board: pigeonMap['board'] as String?,
      serial: pigeonMap['serial'] as String?,
      language: pigeonMap['language'] as String?,
      languageVersion: pigeonMap['languageVersion'] as int?,
      isUnfaithful: pigeonMap['isUnfaithful'] as bool?,
    );
  }
}

class PebbleScanDevicePigeon {
  PebbleScanDevicePigeon({
    this.name,
    this.address,
    this.version,
    this.serialNumber,
    this.color,
    this.runningPRF,
    this.firstUse,
  });

  String? name;
  String? address;
  String? version;
  String? serialNumber;
  int? color;
  bool? runningPRF;
  bool? firstUse;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['name'] = name;
    pigeonMap['address'] = address;
    pigeonMap['version'] = version;
    pigeonMap['serialNumber'] = serialNumber;
    pigeonMap['color'] = color;
    pigeonMap['runningPRF'] = runningPRF;
    pigeonMap['firstUse'] = firstUse;
    return pigeonMap;
  }

  static PebbleScanDevicePigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PebbleScanDevicePigeon(
      name: pigeonMap['name'] as String?,
      address: pigeonMap['address'] as String?,
      version: pigeonMap['version'] as String?,
      serialNumber: pigeonMap['serialNumber'] as String?,
      color: pigeonMap['color'] as int?,
      runningPRF: pigeonMap['runningPRF'] as bool?,
      firstUse: pigeonMap['firstUse'] as bool?,
    );
  }
}

class WatchConnectionStatePigeon {
  WatchConnectionStatePigeon({
    this.isConnected,
    this.isConnecting,
    this.currentWatchAddress,
    this.currentConnectedWatch,
  });

  bool? isConnected;
  bool? isConnecting;
  String? currentWatchAddress;
  PebbleDevicePigeon? currentConnectedWatch;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['isConnected'] = isConnected;
    pigeonMap['isConnecting'] = isConnecting;
    pigeonMap['currentWatchAddress'] = currentWatchAddress;
    pigeonMap['currentConnectedWatch'] = currentConnectedWatch == null ? null : currentConnectedWatch!.encode();
    return pigeonMap;
  }

  static WatchConnectionStatePigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return WatchConnectionStatePigeon(
      isConnected: pigeonMap['isConnected'] as bool?,
      isConnecting: pigeonMap['isConnecting'] as bool?,
      currentWatchAddress: pigeonMap['currentWatchAddress'] as String?,
      currentConnectedWatch: pigeonMap['currentConnectedWatch'] != null
          ? PebbleDevicePigeon.decode(pigeonMap['currentConnectedWatch']!)
          : null,
    );
  }
}

class TimelinePinPigeon {
  TimelinePinPigeon({
    this.itemId,
    this.parentId,
    this.timestamp,
    this.type,
    this.duration,
    this.isVisible,
    this.isFloating,
    this.isAllDay,
    this.persistQuickView,
    this.layout,
    this.attributesJson,
    this.actionsJson,
  });

  String? itemId;
  String? parentId;
  int? timestamp;
  int? type;
  int? duration;
  bool? isVisible;
  bool? isFloating;
  bool? isAllDay;
  bool? persistQuickView;
  int? layout;
  String? attributesJson;
  String? actionsJson;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['itemId'] = itemId;
    pigeonMap['parentId'] = parentId;
    pigeonMap['timestamp'] = timestamp;
    pigeonMap['type'] = type;
    pigeonMap['duration'] = duration;
    pigeonMap['isVisible'] = isVisible;
    pigeonMap['isFloating'] = isFloating;
    pigeonMap['isAllDay'] = isAllDay;
    pigeonMap['persistQuickView'] = persistQuickView;
    pigeonMap['layout'] = layout;
    pigeonMap['attributesJson'] = attributesJson;
    pigeonMap['actionsJson'] = actionsJson;
    return pigeonMap;
  }

  static TimelinePinPigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TimelinePinPigeon(
      itemId: pigeonMap['itemId'] as String?,
      parentId: pigeonMap['parentId'] as String?,
      timestamp: pigeonMap['timestamp'] as int?,
      type: pigeonMap['type'] as int?,
      duration: pigeonMap['duration'] as int?,
      isVisible: pigeonMap['isVisible'] as bool?,
      isFloating: pigeonMap['isFloating'] as bool?,
      isAllDay: pigeonMap['isAllDay'] as bool?,
      persistQuickView: pigeonMap['persistQuickView'] as bool?,
      layout: pigeonMap['layout'] as int?,
      attributesJson: pigeonMap['attributesJson'] as String?,
      actionsJson: pigeonMap['actionsJson'] as String?,
    );
  }
}

class ActionTrigger {
  ActionTrigger({
    this.itemId,
    this.actionId,
    this.attributesJson,
  });

  String? itemId;
  int? actionId;
  String? attributesJson;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['itemId'] = itemId;
    pigeonMap['actionId'] = actionId;
    pigeonMap['attributesJson'] = attributesJson;
    return pigeonMap;
  }

  static ActionTrigger decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ActionTrigger(
      itemId: pigeonMap['itemId'] as String?,
      actionId: pigeonMap['actionId'] as int?,
      attributesJson: pigeonMap['attributesJson'] as String?,
    );
  }
}

class ActionResponsePigeon {
  ActionResponsePigeon({
    this.success,
    this.attributesJson,
  });

  bool? success;
  String? attributesJson;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['success'] = success;
    pigeonMap['attributesJson'] = attributesJson;
    return pigeonMap;
  }

  static ActionResponsePigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ActionResponsePigeon(
      success: pigeonMap['success'] as bool?,
      attributesJson: pigeonMap['attributesJson'] as String?,
    );
  }
}

class NotifActionExecuteReq {
  NotifActionExecuteReq({
    this.itemId,
    this.actionId,
    this.responseText,
  });

  String? itemId;
  int? actionId;
  String? responseText;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['itemId'] = itemId;
    pigeonMap['actionId'] = actionId;
    pigeonMap['responseText'] = responseText;
    return pigeonMap;
  }

  static NotifActionExecuteReq decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return NotifActionExecuteReq(
      itemId: pigeonMap['itemId'] as String?,
      actionId: pigeonMap['actionId'] as int?,
      responseText: pigeonMap['responseText'] as String?,
    );
  }
}

class NotificationPigeon {
  NotificationPigeon({
    this.packageId,
    this.notifId,
    this.appName,
    this.tagId,
    this.title,
    this.text,
    this.category,
    this.color,
    this.messagesJson,
    this.actionsJson,
  });

  String? packageId;
  int? notifId;
  String? appName;
  String? tagId;
  String? title;
  String? text;
  String? category;
  int? color;
  String? messagesJson;
  String? actionsJson;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['packageId'] = packageId;
    pigeonMap['notifId'] = notifId;
    pigeonMap['appName'] = appName;
    pigeonMap['tagId'] = tagId;
    pigeonMap['title'] = title;
    pigeonMap['text'] = text;
    pigeonMap['category'] = category;
    pigeonMap['color'] = color;
    pigeonMap['messagesJson'] = messagesJson;
    pigeonMap['actionsJson'] = actionsJson;
    return pigeonMap;
  }

  static NotificationPigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return NotificationPigeon(
      packageId: pigeonMap['packageId'] as String?,
      notifId: pigeonMap['notifId'] as int?,
      appName: pigeonMap['appName'] as String?,
      tagId: pigeonMap['tagId'] as String?,
      title: pigeonMap['title'] as String?,
      text: pigeonMap['text'] as String?,
      category: pigeonMap['category'] as String?,
      color: pigeonMap['color'] as int?,
      messagesJson: pigeonMap['messagesJson'] as String?,
      actionsJson: pigeonMap['actionsJson'] as String?,
    );
  }
}

class AppEntriesPigeon {
  AppEntriesPigeon({
    this.appName,
    this.packageId,
  });

  List<String?>? appName;
  List<String?>? packageId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['appName'] = appName;
    pigeonMap['packageId'] = packageId;
    return pigeonMap;
  }

  static AppEntriesPigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AppEntriesPigeon(
      appName: (pigeonMap['appName'] as List<Object?>?)?.cast<String?>(),
      packageId: (pigeonMap['packageId'] as List<Object?>?)?.cast<String?>(),
    );
  }
}

class PbwAppInfo {
  PbwAppInfo({
    this.isValid,
    this.uuid,
    this.shortName,
    this.longName,
    this.companyName,
    this.versionCode,
    this.versionLabel,
    this.appKeys,
    this.capabilities,
    this.resources,
    this.sdkVersion,
    this.targetPlatforms,
    this.watchapp,
  });

  bool? isValid;
  String? uuid;
  String? shortName;
  String? longName;
  String? companyName;
  int? versionCode;
  String? versionLabel;
  Map<String?, int?>? appKeys;
  List<String?>? capabilities;
  List<WatchResource?>? resources;
  String? sdkVersion;
  List<String?>? targetPlatforms;
  WatchappInfo? watchapp;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['isValid'] = isValid;
    pigeonMap['uuid'] = uuid;
    pigeonMap['shortName'] = shortName;
    pigeonMap['longName'] = longName;
    pigeonMap['companyName'] = companyName;
    pigeonMap['versionCode'] = versionCode;
    pigeonMap['versionLabel'] = versionLabel;
    pigeonMap['appKeys'] = appKeys;
    pigeonMap['capabilities'] = capabilities;
    pigeonMap['resources'] = resources;
    pigeonMap['sdkVersion'] = sdkVersion;
    pigeonMap['targetPlatforms'] = targetPlatforms;
    pigeonMap['watchapp'] = watchapp == null ? null : watchapp!.encode();
    return pigeonMap;
  }

  static PbwAppInfo decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return PbwAppInfo(
      isValid: pigeonMap['isValid'] as bool?,
      uuid: pigeonMap['uuid'] as String?,
      shortName: pigeonMap['shortName'] as String?,
      longName: pigeonMap['longName'] as String?,
      companyName: pigeonMap['companyName'] as String?,
      versionCode: pigeonMap['versionCode'] as int?,
      versionLabel: pigeonMap['versionLabel'] as String?,
      appKeys: (pigeonMap['appKeys'] as Map<Object?, Object?>?)?.cast<String?, int?>(),
      capabilities: (pigeonMap['capabilities'] as List<Object?>?)?.cast<String?>(),
      resources: (pigeonMap['resources'] as List<Object?>?)?.cast<WatchResource?>(),
      sdkVersion: pigeonMap['sdkVersion'] as String?,
      targetPlatforms: (pigeonMap['targetPlatforms'] as List<Object?>?)?.cast<String?>(),
      watchapp: pigeonMap['watchapp'] != null
          ? WatchappInfo.decode(pigeonMap['watchapp']!)
          : null,
    );
  }
}

class WatchappInfo {
  WatchappInfo({
    this.watchface,
    this.hiddenApp,
    this.onlyShownOnCommunication,
  });

  bool? watchface;
  bool? hiddenApp;
  bool? onlyShownOnCommunication;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['watchface'] = watchface;
    pigeonMap['hiddenApp'] = hiddenApp;
    pigeonMap['onlyShownOnCommunication'] = onlyShownOnCommunication;
    return pigeonMap;
  }

  static WatchappInfo decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return WatchappInfo(
      watchface: pigeonMap['watchface'] as bool?,
      hiddenApp: pigeonMap['hiddenApp'] as bool?,
      onlyShownOnCommunication: pigeonMap['onlyShownOnCommunication'] as bool?,
    );
  }
}

class WatchResource {
  WatchResource({
    this.file,
    this.menuIcon,
    this.name,
    this.type,
  });

  String? file;
  bool? menuIcon;
  String? name;
  String? type;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['file'] = file;
    pigeonMap['menuIcon'] = menuIcon;
    pigeonMap['name'] = name;
    pigeonMap['type'] = type;
    return pigeonMap;
  }

  static WatchResource decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return WatchResource(
      file: pigeonMap['file'] as String?,
      menuIcon: pigeonMap['menuIcon'] as bool?,
      name: pigeonMap['name'] as String?,
      type: pigeonMap['type'] as String?,
    );
  }
}

class InstallData {
  InstallData({
    required this.uri,
    required this.appInfo,
    required this.stayOffloaded,
  });

  String uri;
  PbwAppInfo appInfo;
  bool stayOffloaded;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['uri'] = uri;
    pigeonMap['appInfo'] = appInfo == null ? null : appInfo!.encode();
    pigeonMap['stayOffloaded'] = stayOffloaded;
    return pigeonMap;
  }

  static InstallData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InstallData(
      uri: pigeonMap['uri']! as String,
      appInfo: PbwAppInfo.decode(pigeonMap['appInfo']!),
      stayOffloaded: pigeonMap['stayOffloaded']! as bool,
    );
  }
}

class AppInstallStatus {
  AppInstallStatus({
    required this.progress,
    required this.isInstalling,
  });

  double progress;
  bool isInstalling;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['progress'] = progress;
    pigeonMap['isInstalling'] = isInstalling;
    return pigeonMap;
  }

  static AppInstallStatus decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AppInstallStatus(
      progress: pigeonMap['progress']! as double,
      isInstalling: pigeonMap['isInstalling']! as bool,
    );
  }
}

class ScreenshotResult {
  ScreenshotResult({
    required this.success,
    this.imagePath,
  });

  bool success;
  String? imagePath;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['success'] = success;
    pigeonMap['imagePath'] = imagePath;
    return pigeonMap;
  }

  static ScreenshotResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return ScreenshotResult(
      success: pigeonMap['success']! as bool,
      imagePath: pigeonMap['imagePath'] as String?,
    );
  }
}

class AppLogEntry {
  AppLogEntry({
    required this.uuid,
    required this.timestamp,
    required this.level,
    required this.lineNumber,
    required this.filename,
    required this.message,
  });

  String uuid;
  int timestamp;
  int level;
  int lineNumber;
  String filename;
  String message;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['uuid'] = uuid;
    pigeonMap['timestamp'] = timestamp;
    pigeonMap['level'] = level;
    pigeonMap['lineNumber'] = lineNumber;
    pigeonMap['filename'] = filename;
    pigeonMap['message'] = message;
    return pigeonMap;
  }

  static AppLogEntry decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AppLogEntry(
      uuid: pigeonMap['uuid']! as String,
      timestamp: pigeonMap['timestamp']! as int,
      level: pigeonMap['level']! as int,
      lineNumber: pigeonMap['lineNumber']! as int,
      filename: pigeonMap['filename']! as String,
      message: pigeonMap['message']! as String,
    );
  }
}

class OAuthResult {
  OAuthResult({
    this.code,
    this.state,
    this.error,
  });

  String? code;
  String? state;
  String? error;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['code'] = code;
    pigeonMap['state'] = state;
    pigeonMap['error'] = error;
    return pigeonMap;
  }

  static OAuthResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return OAuthResult(
      code: pigeonMap['code'] as String?,
      state: pigeonMap['state'] as String?,
      error: pigeonMap['error'] as String?,
    );
  }
}

class NotifChannelPigeon {
  NotifChannelPigeon({
    this.packageId,
    this.channelId,
    this.channelName,
    this.channelDesc,
    this.delete,
  });

  String? packageId;
  String? channelId;
  String? channelName;
  String? channelDesc;
  bool? delete;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['packageId'] = packageId;
    pigeonMap['channelId'] = channelId;
    pigeonMap['channelName'] = channelName;
    pigeonMap['channelDesc'] = channelDesc;
    pigeonMap['delete'] = delete;
    return pigeonMap;
  }

  static NotifChannelPigeon decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return NotifChannelPigeon(
      packageId: pigeonMap['packageId'] as String?,
      channelId: pigeonMap['channelId'] as String?,
      channelName: pigeonMap['channelName'] as String?,
      channelDesc: pigeonMap['channelDesc'] as String?,
      delete: pigeonMap['delete'] as bool?,
    );
  }
}

class _ScanCallbacksCodec extends StandardMessageCodec {
  const _ScanCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ListWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class ScanCallbacks {
  static const MessageCodec<Object?> codec = _ScanCallbacksCodec();

  void onScanUpdate(ListWrapper pebbles);
  void onScanStarted();
  void onScanStopped();
  static void setup(ScanCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanUpdate', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.ScanCallbacks.onScanUpdate was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ListWrapper? arg_pebbles = (args[0] as ListWrapper?);
          assert(arg_pebbles != null, 'Argument for dev.flutter.pigeon.ScanCallbacks.onScanUpdate was null, expected non-null ListWrapper.');
          api.onScanUpdate(arg_pebbles!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanStarted', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onScanStarted();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanStopped', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onScanStopped();
          return;
        });
      }
    }
  }
}

class _ConnectionCallbacksCodec extends StandardMessageCodec {
  const _ConnectionCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PebbleDevicePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is PebbleFirmwarePigeon) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchConnectionStatePigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return PebbleDevicePigeon.decode(readValue(buffer)!);
      
      case 129:       
        return PebbleFirmwarePigeon.decode(readValue(buffer)!);
      
      case 130:       
        return WatchConnectionStatePigeon.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class ConnectionCallbacks {
  static const MessageCodec<Object?> codec = _ConnectionCallbacksCodec();

  void onWatchConnectionStateChanged(WatchConnectionStatePigeon newState);
  static void setup(ConnectionCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final WatchConnectionStatePigeon? arg_newState = (args[0] as WatchConnectionStatePigeon?);
          assert(arg_newState != null, 'Argument for dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged was null, expected non-null WatchConnectionStatePigeon.');
          api.onWatchConnectionStateChanged(arg_newState!);
          return;
        });
      }
    }
  }
}

class _RawIncomingPacketsCallbacksCodec extends StandardMessageCodec {
  const _RawIncomingPacketsCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ListWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class RawIncomingPacketsCallbacks {
  static const MessageCodec<Object?> codec = _RawIncomingPacketsCallbacksCodec();

  void onPacketReceived(ListWrapper listOfBytes);
  static void setup(RawIncomingPacketsCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ListWrapper? arg_listOfBytes = (args[0] as ListWrapper?);
          assert(arg_listOfBytes != null, 'Argument for dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived was null, expected non-null ListWrapper.');
          api.onPacketReceived(arg_listOfBytes!);
          return;
        });
      }
    }
  }
}

class _PairCallbacksCodec extends StandardMessageCodec {
  const _PairCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class PairCallbacks {
  static const MessageCodec<Object?> codec = _PairCallbacksCodec();

  void onWatchPairComplete(StringWrapper address);
  static void setup(PairCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.PairCallbacks.onWatchPairComplete', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.PairCallbacks.onWatchPairComplete was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_address = (args[0] as StringWrapper?);
          assert(arg_address != null, 'Argument for dev.flutter.pigeon.PairCallbacks.onWatchPairComplete was null, expected non-null StringWrapper.');
          api.onWatchPairComplete(arg_address!);
          return;
        });
      }
    }
  }
}

class _CalendarCallbacksCodec extends StandardMessageCodec {
  const _CalendarCallbacksCodec();
}
abstract class CalendarCallbacks {
  static const MessageCodec<Object?> codec = _CalendarCallbacksCodec();

  Future<void> doFullCalendarSync();
  static void setup(CalendarCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.CalendarCallbacks.doFullCalendarSync', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          await api.doFullCalendarSync();
          return;
        });
      }
    }
  }
}

class _TimelineCallbacksCodec extends StandardMessageCodec {
  const _TimelineCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ActionResponsePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is ActionTrigger) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ActionResponsePigeon.decode(readValue(buffer)!);
      
      case 129:       
        return ActionTrigger.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class TimelineCallbacks {
  static const MessageCodec<Object?> codec = _TimelineCallbacksCodec();

  void syncTimelineToWatch();
  Future<ActionResponsePigeon> handleTimelineAction(ActionTrigger actionTrigger);
  static void setup(TimelineCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.TimelineCallbacks.syncTimelineToWatch', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.syncTimelineToWatch();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.TimelineCallbacks.handleTimelineAction', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.TimelineCallbacks.handleTimelineAction was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ActionTrigger? arg_actionTrigger = (args[0] as ActionTrigger?);
          assert(arg_actionTrigger != null, 'Argument for dev.flutter.pigeon.TimelineCallbacks.handleTimelineAction was null, expected non-null ActionTrigger.');
          final ActionResponsePigeon output = await api.handleTimelineAction(arg_actionTrigger!);
          return output;
        });
      }
    }
  }
}

class _IntentCallbacksCodec extends StandardMessageCodec {
  const _IntentCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class IntentCallbacks {
  static const MessageCodec<Object?> codec = _IntentCallbacksCodec();

  void openUri(StringWrapper uri);
  static void setup(IntentCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.IntentCallbacks.openUri', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.IntentCallbacks.openUri was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_uri = (args[0] as StringWrapper?);
          assert(arg_uri != null, 'Argument for dev.flutter.pigeon.IntentCallbacks.openUri was null, expected non-null StringWrapper.');
          api.openUri(arg_uri!);
          return;
        });
      }
    }
  }
}

class _BackgroundAppInstallCallbacksCodec extends StandardMessageCodec {
  const _BackgroundAppInstallCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is InstallData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is PbwAppInfo) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchResource) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchappInfo) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return InstallData.decode(readValue(buffer)!);
      
      case 129:       
        return PbwAppInfo.decode(readValue(buffer)!);
      
      case 130:       
        return StringWrapper.decode(readValue(buffer)!);
      
      case 131:       
        return WatchResource.decode(readValue(buffer)!);
      
      case 132:       
        return WatchappInfo.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class BackgroundAppInstallCallbacks {
  static const MessageCodec<Object?> codec = _BackgroundAppInstallCallbacksCodec();

  Future<void> beginAppInstall(InstallData installData);
  Future<void> deleteApp(StringWrapper uuid);
  static void setup(BackgroundAppInstallCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.BackgroundAppInstallCallbacks.beginAppInstall', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.BackgroundAppInstallCallbacks.beginAppInstall was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final InstallData? arg_installData = (args[0] as InstallData?);
          assert(arg_installData != null, 'Argument for dev.flutter.pigeon.BackgroundAppInstallCallbacks.beginAppInstall was null, expected non-null InstallData.');
          await api.beginAppInstall(arg_installData!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.BackgroundAppInstallCallbacks.deleteApp', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.BackgroundAppInstallCallbacks.deleteApp was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_uuid = (args[0] as StringWrapper?);
          assert(arg_uuid != null, 'Argument for dev.flutter.pigeon.BackgroundAppInstallCallbacks.deleteApp was null, expected non-null StringWrapper.');
          await api.deleteApp(arg_uuid!);
          return;
        });
      }
    }
  }
}

class _AppInstallStatusCallbacksCodec extends StandardMessageCodec {
  const _AppInstallStatusCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppInstallStatus) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AppInstallStatus.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class AppInstallStatusCallbacks {
  static const MessageCodec<Object?> codec = _AppInstallStatusCallbacksCodec();

  void onStatusUpdated(AppInstallStatus status);
  static void setup(AppInstallStatusCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final AppInstallStatus? arg_status = (args[0] as AppInstallStatus?);
          assert(arg_status != null, 'Argument for dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated was null, expected non-null AppInstallStatus.');
          api.onStatusUpdated(arg_status!);
          return;
        });
      }
    }
  }
}

class _NotificationListeningCodec extends StandardMessageCodec {
  const _NotificationListeningCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is NotifChannelPigeon) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is NotificationPigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else
    if (value is TimelinePinPigeon) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);

      case 129:
        return NotifChannelPigeon.decode(readValue(buffer)!);

      case 130:
        return NotificationPigeon.decode(readValue(buffer)!);
      
      case 131:
        return StringWrapper.decode(readValue(buffer)!);
      
      case 132:
        return TimelinePinPigeon.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class NotificationListening {
  static const MessageCodec<Object?> codec = _NotificationListeningCodec();

  Future<TimelinePinPigeon> handleNotification(NotificationPigeon notification);
  void dismissNotification(StringWrapper itemId);
  Future<BooleanWrapper> shouldNotify(NotifChannelPigeon channel);
  void updateChannel(NotifChannelPigeon channel);
  static void setup(NotificationListening? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.NotificationListening.handleNotification', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.NotificationListening.handleNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NotificationPigeon? arg_notification = (args[0] as NotificationPigeon?);
          assert(arg_notification != null, 'Argument for dev.flutter.pigeon.NotificationListening.handleNotification was null, expected non-null NotificationPigeon.');
          final TimelinePinPigeon output = await api.handleNotification(arg_notification!);
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.NotificationListening.dismissNotification', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.NotificationListening.dismissNotification was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_itemId = (args[0] as StringWrapper?);
          assert(arg_itemId != null, 'Argument for dev.flutter.pigeon.NotificationListening.dismissNotification was null, expected non-null StringWrapper.');
          api.dismissNotification(arg_itemId!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.NotificationListening.shouldNotify', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.NotificationListening.shouldNotify was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NotifChannelPigeon? arg_channel = (args[0] as NotifChannelPigeon?);
          assert(arg_channel != null, 'Argument for dev.flutter.pigeon.NotificationListening.shouldNotify was null, expected non-null NotifChannelPigeon.');
          final BooleanWrapper output = await api.shouldNotify(arg_channel!);
          return output;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.NotificationListening.updateChannel', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.NotificationListening.updateChannel was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final NotifChannelPigeon? arg_channel = (args[0] as NotifChannelPigeon?);
          assert(arg_channel != null, 'Argument for dev.flutter.pigeon.NotificationListening.updateChannel was null, expected non-null NotifChannelPigeon.');
          api.updateChannel(arg_channel!);
          return;
        });
      }
    }
  }
}

class _AppLogCallbacksCodec extends StandardMessageCodec {
  const _AppLogCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppLogEntry) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AppLogEntry.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class AppLogCallbacks {
  static const MessageCodec<Object?> codec = _AppLogCallbacksCodec();

  void onLogReceived(AppLogEntry entry);
  static void setup(AppLogCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.AppLogCallbacks.onLogReceived', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.AppLogCallbacks.onLogReceived was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final AppLogEntry? arg_entry = (args[0] as AppLogEntry?);
          assert(arg_entry != null, 'Argument for dev.flutter.pigeon.AppLogCallbacks.onLogReceived was null, expected non-null AppLogEntry.');
          api.onLogReceived(arg_entry!);
          return;
        });
      }
    }
  }
}

class _NotificationUtilsCodec extends StandardMessageCodec {
  const _NotificationUtilsCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is NotifActionExecuteReq) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);
      
      case 129:       
        return NotifActionExecuteReq.decode(readValue(buffer)!);
      
      case 130:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class NotificationUtils {
  /// Constructor for [NotificationUtils].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NotificationUtils({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _NotificationUtilsCodec();

  Future<BooleanWrapper> dismissNotification(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.dismissNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_itemId]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<void> dismissNotificationWatch(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.dismissNotificationWatch', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_itemId]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> openNotification(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.openNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_itemId]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> executeAction(NotifActionExecuteReq arg_action) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.executeAction', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_action]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ScanControlCodec extends StandardMessageCodec {
  const _ScanControlCodec();
}

class ScanControl {
  /// Constructor for [ScanControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ScanControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ScanControlCodec();

  Future<void> startBleScan() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScanControl.startBleScan', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> startClassicScan() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScanControl.startClassicScan', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _ConnectionControlCodec extends StandardMessageCodec {
  const _ConnectionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is ListWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);
      
      case 129:       
        return ListWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ConnectionControl {
  /// Constructor for [ConnectionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConnectionControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConnectionControlCodec();

  Future<BooleanWrapper> isConnected() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.isConnected', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<void> disconnect() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.disconnect', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> sendRawPacket(ListWrapper arg_listOfBytes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.sendRawPacket', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_listOfBytes]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> observeConnectionChanges() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.observeConnectionChanges', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> cancelObservingConnectionChanges() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.cancelObservingConnectionChanges', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _RawIncomingPacketsControlCodec extends StandardMessageCodec {
  const _RawIncomingPacketsControlCodec();
}

class RawIncomingPacketsControl {
  /// Constructor for [RawIncomingPacketsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RawIncomingPacketsControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RawIncomingPacketsControlCodec();

  Future<void> observeIncomingPackets() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RawIncomingPacketsControl.observeIncomingPackets', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> cancelObservingIncomingPackets() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RawIncomingPacketsControl.cancelObservingIncomingPackets', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _UiConnectionControlCodec extends StandardMessageCodec {
  const _UiConnectionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class UiConnectionControl {
  /// Constructor for [UiConnectionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UiConnectionControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UiConnectionControlCodec();

  Future<void> connectToWatch(StringWrapper arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UiConnectionControl.connectToWatch', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unpairWatch(StringWrapper arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UiConnectionControl.unpairWatch', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_macAddress]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _NotificationsControlCodec extends StandardMessageCodec {
  const _NotificationsControlCodec();
}

class NotificationsControl {
  /// Constructor for [NotificationsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NotificationsControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _NotificationsControlCodec();

  Future<void> sendTestNotification() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationsControl.sendTestNotification', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _IntentControlCodec extends StandardMessageCodec {
  const _IntentControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is OAuthResult) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return OAuthResult.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class IntentControl {
  /// Constructor for [IntentControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  IntentControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _IntentControlCodec();

  Future<void> notifyFlutterReadyForIntents() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.notifyFlutterReadyForIntents', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> notifyFlutterNotReadyForIntents() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.notifyFlutterNotReadyForIntents', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<OAuthResult> waitForOAuth() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.waitForOAuth', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as OAuthResult?)!;
    }
  }
}

class _DebugControlCodec extends StandardMessageCodec {
  const _DebugControlCodec();
}

class DebugControl {
  /// Constructor for [DebugControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DebugControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _DebugControlCodec();

  Future<void> collectLogs() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DebugControl.collectLogs', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _TimelineControlCodec extends StandardMessageCodec {
  const _TimelineControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is TimelinePinPigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return NumberWrapper.decode(readValue(buffer)!);
      
      case 129:       
        return StringWrapper.decode(readValue(buffer)!);
      
      case 130:       
        return TimelinePinPigeon.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class TimelineControl {
  /// Constructor for [TimelineControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TimelineControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _TimelineControlCodec();

  Future<NumberWrapper> addPin(TimelinePinPigeon arg_pin) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.addPin', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_pin]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removePin(StringWrapper arg_pinUuid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.removePin', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_pinUuid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removeAllPins() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.removeAllPins', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }
}

class _BackgroundSetupControlCodec extends StandardMessageCodec {
  const _BackgroundSetupControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return NumberWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class BackgroundSetupControl {
  /// Constructor for [BackgroundSetupControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  BackgroundSetupControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _BackgroundSetupControlCodec();

  Future<void> setupBackground(NumberWrapper arg_callbackHandle) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.BackgroundSetupControl.setupBackground', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_callbackHandle]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _BackgroundControlCodec extends StandardMessageCodec {
  const _BackgroundControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return NumberWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class BackgroundControl {
  /// Constructor for [BackgroundControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  BackgroundControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _BackgroundControlCodec();

  Future<NumberWrapper> notifyFlutterBackgroundStarted() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.BackgroundControl.notifyFlutterBackgroundStarted', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }
}

class _PermissionCheckCodec extends StandardMessageCodec {
  const _PermissionCheckCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PermissionCheck {
  /// Constructor for [PermissionCheck].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PermissionCheck({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PermissionCheckCodec();

  Future<BooleanWrapper> hasLocationPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasLocationPermission', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasCalendarPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasCalendarPermission', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasNotificationAccess() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasNotificationAccess', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasBatteryExclusionEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasBatteryExclusionEnabled', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }
}

class _PermissionControlCodec extends StandardMessageCodec {
  const _PermissionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return NumberWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PermissionControl {
  /// Constructor for [PermissionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PermissionControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PermissionControlCodec();

  Future<NumberWrapper> requestLocationPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestLocationPermission', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> requestCalendarPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestCalendarPermission', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<void> requestNotificationAccess() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestNotificationAccess', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> requestBatteryExclusion() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestBatteryExclusion', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<NumberWrapper> requestBluetoothPermissions() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestBluetoothPermissions', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<void> openPermissionSettings() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.openPermissionSettings', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _CalendarControlCodec extends StandardMessageCodec {
  const _CalendarControlCodec();
}

class CalendarControl {
  /// Constructor for [CalendarControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CalendarControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CalendarControlCodec();

  Future<void> requestCalendarSync() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.requestCalendarSync', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _PigeonLoggerCodec extends StandardMessageCodec {
  const _PigeonLoggerCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PigeonLogger {
  /// Constructor for [PigeonLogger].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PigeonLogger({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PigeonLoggerCodec();

  Future<void> v(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.v', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_message]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> d(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.d', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_message]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> i(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.i', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_message]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> w(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.w', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_message]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> e(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.e', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_message]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _TimelineSyncControlCodec extends StandardMessageCodec {
  const _TimelineSyncControlCodec();
}

class TimelineSyncControl {
  /// Constructor for [TimelineSyncControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TimelineSyncControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _TimelineSyncControlCodec();

  Future<void> syncTimelineToWatchLater() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineSyncControl.syncTimelineToWatchLater', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _WorkaroundsControlCodec extends StandardMessageCodec {
  const _WorkaroundsControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ListWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class WorkaroundsControl {
  /// Constructor for [WorkaroundsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  WorkaroundsControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _WorkaroundsControlCodec();

  Future<ListWrapper> getNeededWorkarounds() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.WorkaroundsControl.getNeededWorkarounds', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ListWrapper?)!;
    }
  }
}

class _AppInstallControlCodec extends StandardMessageCodec {
  const _AppInstallControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is InstallData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is ListWrapper) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is NumberWrapper) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is PbwAppInfo) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchResource) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchappInfo) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);
      
      case 129:       
        return InstallData.decode(readValue(buffer)!);
      
      case 130:       
        return ListWrapper.decode(readValue(buffer)!);
      
      case 131:       
        return NumberWrapper.decode(readValue(buffer)!);
      
      case 132:       
        return PbwAppInfo.decode(readValue(buffer)!);
      
      case 133:       
        return StringWrapper.decode(readValue(buffer)!);
      
      case 134:       
        return WatchResource.decode(readValue(buffer)!);
      
      case 135:       
        return WatchappInfo.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class AppInstallControl {
  /// Constructor for [AppInstallControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppInstallControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _AppInstallControlCodec();

  Future<PbwAppInfo> getAppInfo(StringWrapper arg_localPbwUri) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.getAppInfo', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_localPbwUri]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as PbwAppInfo?)!;
    }
  }

  Future<BooleanWrapper> beginAppInstall(InstallData arg_installData) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.beginAppInstall', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_installData]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> beginAppDeletion(StringWrapper arg_uuid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.beginAppDeletion', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_uuid]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }

  Future<NumberWrapper> insertAppIntoBlobDb(StringWrapper arg_uuidString) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.insertAppIntoBlobDb', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_uuidString]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removeAppFromBlobDb(StringWrapper arg_appUuidString) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.removeAppFromBlobDb', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_appUuidString]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removeAllApps() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.removeAllApps', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }

  Future<void> subscribeToAppStatus() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.subscribeToAppStatus', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unsubscribeFromAppStatus() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.unsubscribeFromAppStatus', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<NumberWrapper> sendAppOrderToWatch(ListWrapper arg_uuidStringList) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.sendAppOrderToWatch', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_uuidStringList]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as NumberWrapper?)!;
    }
  }
}

class _AppLifecycleControlCodec extends StandardMessageCodec {
  const _AppLifecycleControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is StringWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return BooleanWrapper.decode(readValue(buffer)!);
      
      case 129:       
        return StringWrapper.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class AppLifecycleControl {
  /// Constructor for [AppLifecycleControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppLifecycleControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _AppLifecycleControlCodec();

  Future<BooleanWrapper> openAppOnTheWatch(StringWrapper arg_uuidString) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLifecycleControl.openAppOnTheWatch', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_uuidString]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as BooleanWrapper?)!;
    }
  }
}

class _PackageDetailsCodec extends StandardMessageCodec {
  const _PackageDetailsCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppEntriesPigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AppEntriesPigeon.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class PackageDetails {
  /// Constructor for [PackageDetails].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PackageDetails({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PackageDetailsCodec();

  Future<AppEntriesPigeon> getPackageList() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PackageDetails.getPackageList', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as AppEntriesPigeon?)!;
    }
  }
}

class _ScreenshotsControlCodec extends StandardMessageCodec {
  const _ScreenshotsControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ScreenshotResult) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return ScreenshotResult.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class ScreenshotsControl {
  /// Constructor for [ScreenshotsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ScreenshotsControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ScreenshotsControlCodec();

  Future<ScreenshotResult> takeWatchScreenshot() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScreenshotsControl.takeWatchScreenshot', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as ScreenshotResult?)!;
    }
  }
}

class _AppLogControlCodec extends StandardMessageCodec {
  const _AppLogControlCodec();
}

class AppLogControl {
  /// Constructor for [AppLogControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppLogControl({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _AppLogControlCodec();

  Future<void> startSendingLogs() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLogControl.startSendingLogs', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> stopSendingLogs() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLogControl.stopSendingLogs', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}

class _KeepUnusedHackCodec extends StandardMessageCodec {
  const _KeepUnusedHackCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PebbleScanDevicePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is WatchResource) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return PebbleScanDevicePigeon.decode(readValue(buffer)!);
      
      case 129:       
        return WatchResource.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class KeepUnusedHack {
  /// Constructor for [KeepUnusedHack].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  KeepUnusedHack({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _KeepUnusedHackCodec();

  Future<void> keepPebbleScanDevicePigeon(PebbleScanDevicePigeon arg_cls) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KeepUnusedHack.keepPebbleScanDevicePigeon', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_cls]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> keepWatchResource(WatchResource arg_cls) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KeepUnusedHack.keepWatchResource', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_cls]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}
